<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mac Meng&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mactive.github.io/"/>
  <updated>2020-12-29T01:31:06.102Z</updated>
  <id>http://mactive.github.io/</id>
  
  <author>
    <name>Mac Meng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序员眼中的极限运动</title>
    <link href="http://mactive.github.io/2020/12/29/engineer_xsport/"/>
    <id>http://mactive.github.io/2020/12/29/engineer_xsport/</id>
    <published>2020-12-29T00:01:00.000Z</published>
    <updated>2020-12-29T01:31:06.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-我尝试的极限运动"><a href="#1-我尝试的极限运动" class="headerlink" title="1. 我尝试的极限运动"></a>1. 我尝试的极限运动</h2><p>2020年尝试的都是板上运动, 桨板, 滑板和滑雪. 当然我玩的还不比较初级.</p><p>###桨板🏄:<br>2次21公里长距离, 用时3小时多一些.<br>一次13公里海划, 基本是跪着划完的.<br>平时训练强度在 5-10公里之间. 心率120左右</p><h3 id="滑雪⛷"><a href="#滑雪⛷" class="headerlink" title="滑雪⛷:"></a>滑雪⛷:</h3><p>2次崇礼, 3次南山, 最高难度25-30度左右的坡度.<br>双板中下级水平吧, 陡坡缓降不怂, 高速换刃不溜.<br>一次能滑个20公里. 滑行心率140左右</p><h3 id="滑板🛹"><a href="#滑板🛹" class="headerlink" title="滑板🛹:"></a>滑板🛹:</h3><p>周末陪孩子公园溜达, 右转转弯半径5m, 左转7m左右, 坡度10度左右敢下. 可以板上换脚和转身. 没啥心率纯玩.</p><h3 id="身体准备"><a href="#身体准备" class="headerlink" title="身体准备"></a>身体准备</h3><p>板上运动对你的核心力量要求很高, 平时要多联系腰腹和腿部肌肉. 这样可以在板上随时调整重心, 方便做出各种姿势.</p><h3 id="心理准备"><a href="#心理准备" class="headerlink" title="心理准备"></a>心理准备</h3><p>除此之外心理建设也很需要, 在可控范围内要勇敢尝试, 可能在外人开起来像是个疯子. 将高风险事件拆解成小的步骤, 这个要推荐一下 <a href="https://www.bilibili.com/video/BV18J411t7LR" target="_blank" rel="noopener">楚格山里人的视频</a>, 简单易学. 风险拆解和风险控制和软件工程的很多思想非常像. </p><h2 id="2-编程也是一种极限运动"><a href="#2-编程也是一种极限运动" class="headerlink" title="2. 编程也是一种极限运动"></a>2. 编程也是一种极限运动</h2><p>极限运行的有几个让人着迷的地方, 容易带给你极致体验</p><ul><li>速度感: 同样的风景, 换一个速度, 换一个高度去看会完全不同.</li><li>视觉冲击: 在海边看风景, 和从海里看陆地完全不同, 视角非常宏大. 滑雪时山顶的夕阳, 配上纵身一跃简直完美. 编程时的大屏高刷显示器就是爽.</li><li>高心率, 高浓度多巴胺: 人体本身的特质, 类似发动机的高速旋转的嘶吼, 还有机器在编译的性能狂飙和风扇狂转.</li><li>不可控: 在失控的边缘试探, 和结束之后喜悦感. 和软件上线有异曲同工之妙</li></ul><h2 id="3-风险和成本"><a href="#3-风险和成本" class="headerlink" title="3. 风险和成本"></a>3. 风险和成本</h2><p>总体来说, 这种产业化的极限运动, 风险还是很小的. 而且而方便都照顾的周全.<br>你需要的就是准备好你的身体和心态, 玩出自己的特色.</p><p>编程尤其是<code>ML/AI</code>领域也是, 各种教学和实践场地都给你准备好了, 你只需要全情投入, 玩出你的特色来.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-我尝试的极限运动&quot;&gt;&lt;a href=&quot;#1-我尝试的极限运动&quot; class=&quot;headerlink&quot; title=&quot;1. 我尝试的极限运动&quot;&gt;&lt;/a&gt;1. 我尝试的极限运动&lt;/h2&gt;&lt;p&gt;2020年尝试的都是板上运动, 桨板, 滑板和滑雪. 当然我玩的还不比较
      
    
    </summary>
    
    
      <category term="life" scheme="http://mactive.github.io/tags/life/"/>
    
      <category term="extremesport" scheme="http://mactive.github.io/tags/extremesport/"/>
    
  </entry>
  
  <entry>
    <title>2020年终总结</title>
    <link href="http://mactive.github.io/2020/12/28/2021/"/>
    <id>http://mactive.github.io/2020/12/28/2021/</id>
    <published>2020-12-28T00:30:00.000Z</published>
    <updated>2020-12-28T01:15:12.423Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2020年是平凡的一年"><a href="#2020年是平凡的一年" class="headerlink" title="2020年是平凡的一年"></a>2020年是平凡的一年</h3><p>体重没有变化, 身材没有变化, 依然还是半马的体力.<br>音乐品味没变, <code>Spotify</code> 里面的音乐还是 <a href="https://open.spotify.com/playlist/37i9dQZF1DX3PFzdbtx1Us?si=beTqLAHxR6O_K31r6s6Rvg" target="_blank" rel="noopener"><code>Concentration</code></a> 和  <code>Chill-out</code> 为主.<br>工作的内容也没有变化, 业务上还有增长和利好, 但是已经没有太多挑战.</p><h3 id="2020年是最不平淡的一年"><a href="#2020年是最不平淡的一年" class="headerlink" title="2020年是最不平淡的一年"></a>2020年是最不平淡的一年</h3><p>世界不同了, 人与人之前的关系变得微妙. 大家也能习惯了一个月不见, 依然能一见如故.<br>虽然科技有点停滞, 但智能和通信领域还是有很多看得见的变化, 自动驾驶, 机器人, 星链等.</p><p>靠着自己的热情在努力的学习 <code>Swift</code>, <code>ReactNative</code>, <code>入门算法知识</code>, <code>美股期权交易</code>, 还有精进各种宿主环境的底层原理, 例如<code>iOS系统底层原理</code>, <code>浏览器原理</code>, <code>机器学习中的数学</code>, <code>价值投资与中国</code>. </p><p>虽然眼看要进入不惑之年, 年龄卡在互联网淘汰高峰期, 但是依然能保持一个纯粹的心, 对真相和原理的探求和平和而不倦的心态, 还是挺不容易的. 大概是是运动和思考给了我力量.</p><h3 id="Self-Drive-自驱-自动驾驶"><a href="#Self-Drive-自驱-自动驾驶" class="headerlink" title="Self Drive - 自驱/自动驾驶"></a>Self Drive - 自驱/自动驾驶</h3><p>这是一个需要自我驱动的年代, 电动车都不例外, 何况<code>people</code>乎.</p><p>从2020年6月份开始坚持<code>每天6:30</code>早起, 已经养成了精准的生物钟, 无论换了环境或者头一天有多累. 早晨准点起来. 喝杯咖啡, 开始今天的学习和思考. 在上班族还未到岗的清晨中高效的完成今天最想做的事情, 并尽可能的记录和记忆下来(不能泛泛的阅读)</p><p>自我驱动的几个要素</p><ol><li><strong>心态</strong>: 注定是经过了迷茫, 消沉, 知耻, 后勇, 平和之后才能获得. 至少我是这样的, 有人的转变比较迅速, 有人会卡在一个地方. 需要不断的励志, 高远的目标, 或者持续的压力. 比如一个上架的App, 一个训练的模型, 一个学习证明.</li><li><strong>条件</strong>: 安静的环境, 尽可能的安静, 避开嘈杂的环境. 例如清晨无人的会议室, 降噪耳机, 咖啡和可以保持专注的音乐同样不可获取.</li><li><strong>持久力</strong>: 每天中午的健身对我来说是件很放松的事情, 尤其健身之后睡那一觉, 可以让我轻松应付下午的杂事. 坚持做一件枯燥的事情之外最好能搭配一些有趣的事情, 有声电子书和vlog都不错</li><li><strong>执行力</strong>: 无情的执行力, 让你不知所措的时候, 就看看执行清单上还有哪些没有完成的事情, 只要开始就好了, 日复一日的量变会引起质变.</li></ol><h3 id="多进程的世界"><a href="#多进程的世界" class="headerlink" title="多进程的世界"></a>多进程的世界</h3><p>在你偷懒的时候, 有人在<code>高效</code>的付出.<br>在你灰心丧气的时候, 有人在斗志昂扬的冲顶.<br>在你赔钱的时候, 有人赚的盆满钵满.</p><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>这次疫情感觉更像是一次洗牌的机会, 而不是灾难.<br>如何能避免内卷, 必须用对的方法, 保护好心态, 持续的走下去.<br><code>Later better than never, 犹未晚也.</code></p><h3 id="Hello-2021"><a href="#Hello-2021" class="headerlink" title="Hello 2021."></a><strong>Hello 2021.</strong></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2020年是平凡的一年&quot;&gt;&lt;a href=&quot;#2020年是平凡的一年&quot; class=&quot;headerlink&quot; title=&quot;2020年是平凡的一年&quot;&gt;&lt;/a&gt;2020年是平凡的一年&lt;/h3&gt;&lt;p&gt;体重没有变化, 身材没有变化, 依然还是半马的体力.&lt;br&gt;音乐品味
      
    
    </summary>
    
    
      <category term="life" scheme="http://mactive.github.io/tags/life/"/>
    
      <category term="think" scheme="http://mactive.github.io/tags/think/"/>
    
  </entry>
  
  <entry>
    <title>桨板初体验</title>
    <link href="http://mactive.github.io/2019/08/06/sup_tour1/"/>
    <id>http://mactive.github.io/2019/08/06/sup_tour1/</id>
    <published>2019-08-05T23:35:00.000Z</published>
    <updated>2020-12-28T00:27:05.587Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/sup_2.jpg" alt="训练营童鞋和教练"></p><h3 id="SUP-Stand-Up-Paddle"><a href="#SUP-Stand-Up-Paddle" class="headerlink" title="SUP = Stand Up Paddle"></a>SUP = Stand Up Paddle</h3><p>老家就有个东昌湖, 从小就在湖里游泳, 每天也举办开放水域比赛. 这个习惯也坚持了10多年, 去年又体验了铁三运动, 在开水中体验了一把竞赛, 45分钟1.5KM游泳, 令我印象深刻. 从此内心一直在寻找, 一个能把水, 户外, 旅行, 亲子, 探险相结合的运动. 最好比较便携, 价格不贵, 有适应性. 可以探索各种水域. 比如河流, 湖泊, 高山湖泊, 近海等. 可旅行可竞技可娱乐. 终于让我找到了. 那就是站立桨板, Stand Up Paddle.</p><p><img src="/images/sup_1.jpg" alt="家乡东昌湖"></p><p>从发展上来说, SUP是从冲浪(Paddle)演变过来, 脚绳和板子, 冲浪板也都有. 不过冲浪难度更高, 最主要需要有浪, 得靠海. 然后河流和湖泊大部分是皮划艇为主要方式. 但是皮划艇一般不方便携带, 所以有同学就把冲浪板和桨一结合, 就产生了桨板. 在海边浪不大的地方也可以划着去旅行等等. 安静的水域那就更合适了. </p><p><img src="/images/sup_3.jpg" alt="冲浪"></p><h3 id="水上运动"><a href="#水上运动" class="headerlink" title="水上运动"></a>水上运动</h3><p>在有海岸线的国家, 可能得有百十个国家吧, 会冲浪的人比比皆是. 在各种电影和电视剧中出镜率很高, 也很有观赏性, 还能海边撩妹, 哈哈. 这项运动在欧美应该和滑板一样普遍, 都考验平衡性.  像是欧洲有些国家划船, 划艇的就比较多, 英国很多名校都有赛艇队, 故此赛艇在第一届奥运会就是正式项目, 可能和他们的航海精神有关吧. 多说两句, 赛艇比较高端, 非常有仪式感, 在顺义奥林匹克水上公园目睹了和鹭赛艇的比赛, 感觉都是高富帅. 皮划艇和桨板就相对就平民一些了.</p><p><img src="/images/sup_5.jpg" alt="单人皮划艇"></p><h3 id="乐趣"><a href="#乐趣" class="headerlink" title="乐趣"></a>乐趣</h3><p>也许是老外们没搞这么多课外补习, 把心思都放在如何在大自然中娱乐自己了. 所以水上运动非常普遍, 有的国家有海, 有河有湖泊, 水边一般也有树林. 你想象一下地球70%以上的面积都被水覆盖, 无论在水上, 水下, 山中, 被自然包围, 身心都感到无比的放松. 如果能变成动态的, 去旅行去探索, 那你会更加愉悦, 这可能就是水上运动的魅力所在.</p><p><img src="/images/sup_4.jpg" alt="老人与狗"></p><h3 id="桨板之平衡"><a href="#桨板之平衡" class="headerlink" title="桨板之平衡"></a>桨板之平衡</h3><p>桨板最难的就是平衡, 毕竟他不是长在脚上的. 有点像我们自己骑自行车, 其实是个动态的平衡. 无论是静止扫桨, 还是不失速拐弯都是在动态中完成的. 考验的是我们对重心的控制, 而且要把自己的重心和板子的重心有机的结合, 再往下讲就涉及高中物理了, 两个不连接物体的重心关系, 这里面还有脚和板子的摩擦力等等. (图)</p><p>重心控制的三轴<br><img src="/images/sup_7.png" alt="XYZ三轴"></p><ol><li>Z轴: 整体重心下移, 所以一开始先趴着, 后来跪着划, 然后站立.</li><li>X轴: 左右的重心控制, 先练习晃动, 然后单侧的正确姿势, 然后单侧不换手滑直</li><li>Y轴: 前后的重心控制, 这个我还没有get, 被人一撞还是容易落水, 只学会了迅速跪下或者坐下. 可能要加入桨上的训练</li></ol><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p><img src="/images/sup_6.jpg" alt="黄色救生衣"></p><p>这次培训里教练一直在各个环节强调安全. 总结了几点</p><ol><li>环境安全-水: 环境评估, 水的深度, 水浅了反而危险. 都是静水环境</li><li>环境安全-风: 风大会对平衡造成很大困难, 风大了</li><li>环境安全-太阳: 夏天做好防晒, 要不就黑炭, 或者过敏.</li><li>自身安全-救生衣: 救生衣一定要穿, 而且要穿对. 不然落水会很累. 有了助浮衣就很轻松</li><li>自身安全-水: 一定要带够水, 不然会严重脱水</li></ol><h3 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h3><p>最开心的莫属桨板拼多多了, 越拼越快乐.<br><img src="/images/sup_7.jpg" alt="拼多多"></p><p>然后还有水上旅行, 把物资往船头一方, 就是水和远方. 顺便还可以清洁环境.</p><p><img src="/images/sup_8.jpg" alt="水上旅行"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/sup_2.jpg&quot; alt=&quot;训练营童鞋和教练&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;SUP-Stand-Up-Paddle&quot;&gt;&lt;a href=&quot;#SUP-Stand-Up-Paddle&quot; class=&quot;headerlink&quot; title=&quot;SU
      
    
    </summary>
    
    
      <category term="life" scheme="http://mactive.github.io/tags/life/"/>
    
      <category term="sup" scheme="http://mactive.github.io/tags/sup/"/>
    
  </entry>
  
  <entry>
    <title>观长安十二时辰感</title>
    <link href="http://mactive.github.io/2019/07/20/changa-12/"/>
    <id>http://mactive.github.io/2019/07/20/changa-12/</id>
    <published>2019-07-20T09:35:00.000Z</published>
    <updated>2020-12-28T00:27:05.584Z</updated>
    
    <content type="html"><![CDATA[<h3 id="望京东路"><a href="#望京东路" class="headerlink" title="望京东路"></a>望京东路</h3><p>先说作者, 马伯庸马亲王是也, 39岁, 工程师家庭, 曾在新西兰留学多年. 30岁之后开始尝试写作. 之前在我司附近上班, 也就是<strong>望京研发园</strong>的施耐德电气. 多年前研发园是望京的荒凉所在, 当时还有摩托, 北电, 爱立信, 诺记等跨国公司大鳄在此驻扎, 却不见阿里的大厦, 美团彼时还未发育, 更不知外卖为何物.</p><p>这十数年, 望京东路见证了外企公司从鼎盛到轰然倒下, 也经历了中国互联网初期的泡沫的此起彼伏, 锤子也在此闪耀过. 后来各大公司崛起, 目前成了上市公司的乐土. 就像书中的长安, 见证了唐朝的兴衰胜败, 各大家族的沉沦起伏.</p><p>不好意思写的文绉绉的, 可能是电视剧看多了. 有点早期白话文的味道.</p><h3 id="业务线"><a href="#业务线" class="headerlink" title="业务线"></a>业务线</h3><p>有人说作者写故事就是在写自己, 我也深以为然, 作者感觉自比徐宾徐主事, 着墨颇多. 应该就是作者自身的写照. 潜心研发大案牍术(大数据搜索), 可谓静安寺的算法基石. 同时还发明了竹子造纸法, 自觉可以救国于危难. 一开始被人怀疑财产去处, 应该是买了巨量的书籍和史料, 这个是为了创造小案牍术, 相当于研发了一台个人计算机, 在静安司可以搞台小型机, 用分治法, 更多的人和输入. 更快的查到案子. </p><p>相信马亲王在写书的时候, 也是以详细的史料作为参考, 同时搜集当时的生活细节, 比如各种计时的方式, 消息传递的方式, 服装服饰还有各式吃的东西, 都描述的非常精确, 细节能带来真实感, 大案牍术也是靠细节. </p><p>当然亲王的架构能力应该也不错. 至少是P9架构师级别的, 能把4条故事条线有机的结合在一起, 能把这个几十主要人物安排的明明白白. 带这么些人做事, 经常有人出状况, 这管理和做事能力也是不容易, 还得非常快的拿到结果才行. 除此之外, 还发明了具有12比特通讯网络的的望楼传信能力, 这个应该都可以申请专利了, 哈哈哈. 很多公司也看专利数量的, 比如我厂.</p><h3 id="技术线"><a href="#技术线" class="headerlink" title="技术线"></a>技术线</h3><p>然后徐宾自己还有时间做做side project, 改良个造纸术什么的. 可以把爱好玩成这个样子, 应该也投入了不少精力, 不过他也能拿到投资, 雇了这么多人开个造纸工厂, 背后可能有徐老的财力支持. 现实中马伯庸自己也经常做综艺节目, 比如圆桌派等, 总能发表一些很有意思的观点. 剧中徐宾造纸厂的那一番慷慨陈词, 让我感觉到了中国发明家或者科学家的萌芽, 一种靠发明改变世界的冲动, 和唐朝的官场之道形成了鲜明的比照. 这也许是作者内心的一种表达. 从改变小事做起, 从某种程度上说张都尉也是在改变身边的一个个小人物, 一个对人一个对事, 让我看到了那种执着.</p><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>剧集还没有更新完, 但是我似乎也看到了结局. 里面人物的转变, 事情的发展, 让观众们大呼过瘾. 也许结局并不重要,例如在龙波眼里谁当道可能并不重要, 他想毁掉的是这个体制, 这个城市, 甚至这个国家. 剧中有想法的人都在为了自己的目的在努力, 用各种手动. </p><p>而你又能看到什么呢, 又想到了什么呢. </p><h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><p>很多事情可能当你做过之后, 你自己才算是真正理解了. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;望京东路&quot;&gt;&lt;a href=&quot;#望京东路&quot; class=&quot;headerlink&quot; title=&quot;望京东路&quot;&gt;&lt;/a&gt;望京东路&lt;/h3&gt;&lt;p&gt;先说作者, 马伯庸马亲王是也, 39岁, 工程师家庭, 曾在新西兰留学多年. 30岁之后开始尝试写作. 之前在我司附近上班,
      
    
    </summary>
    
    
      <category term="life" scheme="http://mactive.github.io/tags/life/"/>
    
      <category term="work" scheme="http://mactive.github.io/tags/work/"/>
    
  </entry>
  
  <entry>
    <title>好久没写了</title>
    <link href="http://mactive.github.io/2019/01/21/2019-01-22/"/>
    <id>http://mactive.github.io/2019/01/21/2019-01-22/</id>
    <published>2019-01-21T01:35:00.000Z</published>
    <updated>2020-12-28T00:27:05.583Z</updated>
    
    <content type="html"><![CDATA[<p><strong>好久不写文章, 倒是写了很多wiki</strong></p><p><strong>2019凛冬将至, 积累自己, 猥琐发育</strong></p><h2 id="最近总结"><a href="#最近总结" class="headerlink" title="最近总结"></a>最近总结</h2><p>C团最近开猿节流, 很多一线干活的RD被莫名其妙的裁掉, 很多中层领导只能眼睁睁看着,或者安排安排. 有人在吐槽, 为什么不裁产品啊, 不裁领导啊. 哈哈, <code>too young, too naive</code>. 你以为中层领导每天不干活么, 在大领导面前, 他们</p><ul><li>PPT,wiki写得好. 方法论一套一套的 – 让领导很放心</li><li>出了问题, 马上认错, 找原因, 找人背锅, 拉会写复盘 – 很重视细节</li><li>跪舔领导, 让领导舒服 – 会做人</li><li>造轮子, 跨团队共建, 动不动就做个网站什么的 – 会来事</li></ul><p>如果你是领导, 你一定也被天天被哄得很开心, 而且敢出去玩享受人生. 怎么忍心裁掉他们呢. 而且这些中层都是不可获取的, 有了他们是么事情搞不定. 要啥产出就有啥, 要什么数据就有什么数据. 在业务蒸蒸日上的情况下, 只要求稳就好了. </p><p>其实这个和一个国家一样的. GDP数据都是能作假的, 不过一旦参与国际上的竞争立马就露馅. 打得过的可以打一打, 打不过的只能用些下三滥的手段了. 你看华为出海, 小米出海感觉都是个笑话. 在国力强盛的时候, 都是厉害了我的国. 一但增长停滞, 或者业务出现下滑, 就开始了各种悲剧了.</p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>所以各位猿们心里一定要有清晰的认识, 比如</p><ul><li>今年要学习那些底层技术, 自己平时业务问题的深挖</li><li>如何提高代码能力, 参与什么样的开源项目, 看什么样的书 </li><li>判断自己领域的技术发展, 并获得应该的影响力, 会让你脱颖而出</li><li>保持一些靠谱的面试, 面试是快速了解外部世界和整体审视自己的机会</li></ul><p>切记: 公司不是家, 同事不是兄弟, 技术也不是信仰. 要多学多思考多实践了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你瞧, 在大厂呆的久了, 也是一套一套的. 希望自己能把方法论用到对的地方</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;好久不写文章, 倒是写了很多wiki&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2019凛冬将至, 积累自己, 猥琐发育&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;最近总结&quot;&gt;&lt;a href=&quot;#最近总结&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="life" scheme="http://mactive.github.io/tags/life/"/>
    
      <category term="work" scheme="http://mactive.github.io/tags/work/"/>
    
  </entry>
  
  <entry>
    <title>选择和选择的方方面面</title>
    <link href="http://mactive.github.io/2018/08/19/2018-08-19/"/>
    <id>http://mactive.github.io/2018/08/19/2018-08-19/</id>
    <published>2018-08-19T10:57:00.000Z</published>
    <updated>2020-12-28T00:27:05.582Z</updated>
    
    <content type="html"><![CDATA[<p><strong>天底下做难做的就是选择, 努力次之</strong></p><p><strong>– 我说的</strong></p><h2 id="为什么要选择"><a href="#为什么要选择" class="headerlink" title="为什么要选择"></a>为什么要选择</h2><p>一般的选择都是被迫的, 地铁抢那个座位, 开发选哪个框架, 租房子选哪个房间, 跳槽选哪个公司. 都是在有限的时间和现实之间做最快的选择. 运气好的话就会开心一阵子, 运气不好的话可能会恶心一阵子甚至耽误好几年. </p><p>除了被迫的选择还有自找的选择, 一些自寻的烦恼.比如 开局选哪个英雄, 用什么战术, 开发的时候用不用typescript, 要不要出国生活等. 因为可能你用什么英雄碰到猪队友都是GG, 用不用typescript领导和同事也不关心. 出不出国都是个穷B. </p><p>那我们为什么要做这种自找的选择, 自寻烦恼呢. 纵观世界300年历史, 从西方殖民者的出海, 到洪堡和达尔文的物种大发现, 再到现在的全球贸易. 每次变革无一不是有识之士跳出舒适区的选择. 为了实现个人的志愿和抱负. 这些人本可以随波逐流, 荣华富贵, 确选了个标新立异. 给了人类无尽的可能.</p><p>拔得太高了, 我不是这个意思. 你们能get就可以了.</p><h2 id="如何做选择"><a href="#如何做选择" class="headerlink" title="如何做选择"></a>如何做选择</h2><p>我们都喜欢做冲动的选择, 比如报个越野跑, 搞个铁三. 将结果交给命运, 一副壮士断腕的气概. 运气好可以大发特发朋友圈, 运气不好默默流泪, 好好养伤. 其实可以随时怂, 不丢人. 毕竟命只有一条, 时间不会倒流, 谁没年轻过, 没被别人忽悠过. </p><a id="more"></a><p>很多不好的选择主要源于对选择背后世界的不了解, 都是信息不对称搞的鬼. 比如找工作, 如果找个在里面工作2年的人聊个天, 喝顿酒, 哪些不好哪些好一清二楚, 就不再盲目. 不至于被招聘者和HR忽悠. 比如如果要出国, 找个在哪个国家生活过的人, 了解下方方面面, 教育医疗和生活, 你就更容易做选择.  </p><p>所以如果没有这样的人和机会, 就需要平时多留意新闻, 从你接触到的各种中介口中套取有利的信息. 比如HR如果8点还联系你, 八成是今天的任务没走完, 那你去了也别想8点之前走. 如果中介各种推销高价的房屋, 那么八成是这些房子不好租, 或者他的收益大. 那你可以去那个国家的论坛去看看大家的吐槽. 或者用英文去网上检索那个国家的方方面面.</p><p>但是所有这些重要的选择的前提是, 自己想清楚想要什么. 看一堆美剧, 打一堆游戏不会帮你解决这个问题. 看书思考或者找过来人聊天可以帮你打开思路. 不过不要灰心, 很多人一辈子都没有解决这个问题, <code>死不瞑目</code>大概就是这种情况. 也有些少年得志迷茫的人, 很多人眼中的人生赢家, 迷失之后堕落的. 所以能想清楚自己几年之内想要什么的已经是很厉害的人了, 我们这种俗人能在起起落落落~~中, 保持身材不走样, 头发不谢顶已属不易.</p><p>还有一点是如果你有家人, (单身狗7夕快乐), 最好也让他们思考一下想要的是什么. </p><h2 id="如何做了选择不后悔"><a href="#如何做了选择不后悔" class="headerlink" title="如何做了选择不后悔"></a>如何做了选择不后悔</h2><p><strong>天底下最贵的药就是后悔药</strong><br><strong>别人说的</strong></p><p>厉害的人有3个特点</p><ol><li>知道在什么时间做什么, 并能把事情做出来. (上学学到的)</li><li>能不择一切手段达到目的, 并能让各方都有一定的满足感. (公司学到的)</li><li>能预计到未来一段时间变化, 并不断调整策略借势让他发生. (还没学到)</li></ol><p>如果你没有那么厉害, 那后悔是肯定的, 哈哈<code>扎心了</code>. 如果想不后悔, 就请尽量做到上面3点吧.</p><h2 id="最近做了什么样的选择"><a href="#最近做了什么样的选择" class="headerlink" title="最近做了什么样的选择"></a>最近做了什么样的选择</h2><p>无论在什么环境中, 都坚持做正确的选择和高附加值的事情. 没有<code>Follow my heart</code>出国生活. 主要是去新加坡成本真的好高, 房子和学校花掉年收入的一般, 公司这边还有不错的增长空间, 努力做到上面3点, 提高自己的硬实力, (没有硬实力的人才只跟你讲软素质). 感觉日本 &lt; 加拿大 &lt; 北欧这3个国家可能才是目的地. 争取在这几年去看一看. 修正一下航向, 用更大的动力前进, 还得存一些油在世界上各个港口, 以免不时之需. </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这个全球一体化的时代, 祝一切平安, 大家都好. 要不谁都不会好过.<br><strong>Make love no war.</strong></p><p>最近写PPT写多了, 感觉写文章都八股了.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;天底下做难做的就是选择, 努力次之&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;– 我说的&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么要选择&quot;&gt;&lt;a href=&quot;#为什么要选择&quot; class=&quot;headerlink&quot; title=&quot;为什么要选择&quot;&gt;&lt;/a&gt;为什么要选择&lt;/h2&gt;&lt;p&gt;一般的选择都是被迫的, 地铁抢那个座位, 开发选哪个框架, 租房子选哪个房间, 跳槽选哪个公司. 都是在有限的时间和现实之间做最快的选择. 运气好的话就会开心一阵子, 运气不好的话可能会恶心一阵子甚至耽误好几年. &lt;/p&gt;
&lt;p&gt;除了被迫的选择还有自找的选择, 一些自寻的烦恼.比如 开局选哪个英雄, 用什么战术, 开发的时候用不用typescript, 要不要出国生活等. 因为可能你用什么英雄碰到猪队友都是GG, 用不用typescript领导和同事也不关心. 出不出国都是个穷B. &lt;/p&gt;
&lt;p&gt;那我们为什么要做这种自找的选择, 自寻烦恼呢. 纵观世界300年历史, 从西方殖民者的出海, 到洪堡和达尔文的物种大发现, 再到现在的全球贸易. 每次变革无一不是有识之士跳出舒适区的选择. 为了实现个人的志愿和抱负. 这些人本可以随波逐流, 荣华富贵, 确选了个标新立异. 给了人类无尽的可能.&lt;/p&gt;
&lt;p&gt;拔得太高了, 我不是这个意思. 你们能get就可以了.&lt;/p&gt;
&lt;h2 id=&quot;如何做选择&quot;&gt;&lt;a href=&quot;#如何做选择&quot; class=&quot;headerlink&quot; title=&quot;如何做选择&quot;&gt;&lt;/a&gt;如何做选择&lt;/h2&gt;&lt;p&gt;我们都喜欢做冲动的选择, 比如报个越野跑, 搞个铁三. 将结果交给命运, 一副壮士断腕的气概. 运气好可以大发特发朋友圈, 运气不好默默流泪, 好好养伤. 其实可以随时怂, 不丢人. 毕竟命只有一条, 时间不会倒流, 谁没年轻过, 没被别人忽悠过. &lt;/p&gt;
    
    </summary>
    
    
      <category term="life" scheme="http://mactive.github.io/tags/life/"/>
    
      <category term="work" scheme="http://mactive.github.io/tags/work/"/>
    
  </entry>
  
  <entry>
    <title>又穷又浪</title>
    <link href="http://mactive.github.io/2018/07/24/2018-07-24/"/>
    <id>http://mactive.github.io/2018/07/24/2018-07-24/</id>
    <published>2018-07-24T01:21:00.000Z</published>
    <updated>2020-12-28T00:27:05.582Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/lang_1.jpg" alt></p><p>今天北京下着大暴雨, 从气象雷达上看云层挺厚的, 估计下雨会持续到下班. 这种天气还坚持上班的不是穷就是浪, 还有我这种又穷又浪的.</p><p>年纪稍微涨了一些之后, 多少会怀疑自己, 怀疑选择, 怀疑方向. 看一些书和电影之后, 在一两天之内能感觉到振奋和清醒. 一周之后便有开始迷茫. 有时候跑步能给你打一针鸡血, 出去浪能持续久一点. 不过这和吃药没有什么本质区别, 都是化学激素在起作用. </p><p>多巴胺啊肾上腺什么的会让你感觉飘飘然, 所以很多成年人一直到死都在追求这些. 我见过40多的徒步大叔, 见过50多岁的跑者, 见过60岁的自驾老哥. 大家在做自己开心的事情时脸上是真诚的微笑, 也愿意敞开心扉和你交谈. </p><p>这是浪的一种表现, 不过有高峰就有低谷, 徒步大叔可能刚和媳妇吵了架, 跑者可能之前得过一场大病, 自驾老哥可能身家都在车上老无所依. 浪后面一般都隐藏着穷. 穷开心, 穷才需要开心, 有钱了追求的是刺激. 当然变得有钱的过程也可以让你开心. 一夜暴富能让很多人改变性格.</p><p>面对国内的激荡的人生, 大起大落. 可能国外的生活多少有些无聊, 需要自己有定力, 能沉下心来做一些枯燥的事情, 比如自己做饭, 自己旅行, 自己更多照顾孩子(国内父爱缺席兼职太严重), 很多娃是又懒又笨. 再比如工作挑战不大, 收入不高, 孩子学校一般, 生活圈子变小等等. </p><p>不过在一个有保障的环境下做一些不那么功利的事情不也是国家富强了之后大家的追求么? 只不过在国家富强的过程中, 裹挟着贪婪和恐惧. 人人都看似有机会, 但都是横向的竞争, 上升通道也是人们想象出来的, 而且所谓的富人在权力之下也是蝼蚁, 白手套也是用完丢弃.</p><p>无论去哪个国家都希望有序公平的环境, 做更优秀的自己, 给家人更好的关怀.</p><p>可能有人看出来我在扯淡了, 没错. 编不下去了.我去看书了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/lang_1.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;今天北京下着大暴雨, 从气象雷达上看云层挺厚的, 估计下雨会持续到下班. 这种天气还坚持上班的不是穷就是浪, 还有我这种又穷又浪的.&lt;/p&gt;
&lt;p&gt;年纪稍微涨了一些之后, 多少会怀疑自己, 
      
    
    </summary>
    
    
      <category term="life" scheme="http://mactive.github.io/tags/life/"/>
    
      <category term="work" scheme="http://mactive.github.io/tags/work/"/>
    
  </entry>
  
  <entry>
    <title>小公司 V.S. 大公司</title>
    <link href="http://mactive.github.io/2017/08/07/people_management/"/>
    <id>http://mactive.github.io/2017/08/07/people_management/</id>
    <published>2017-08-07T00:59:00.000Z</published>
    <updated>2020-12-28T00:27:05.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前前言"><a href="#前前言" class="headerlink" title="前前言"></a>前前言</h2><p>还没写完, 今年有了新的感悟, 想好了再补充</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>也算是在大厂和小厂都呆过,见过,刚过的人. 小厂的时候组建过从0-30的大前端研发队伍, 大厂也前前后后带过10多人.</p><p>本篇文章想从 <code>人员</code>, <code>心理</code>, <code>工程</code>, <code>老板</code>, <code>业绩</code> 几个方面对比一下, 对自己过去3年的工作做个总结, 都是个人的切身感受, 没有太多的理论指导.</p><h2 id="人员"><a href="#人员" class="headerlink" title="人员"></a>人员</h2><p>小公司不好招人, 面试100个可能都招不到1个, 因为没有好简历, 只能叫过来聊聊看, 其实挺浪费时间的. 所以那段公司介绍就显得非常重要, 稍微偏技术一点也许能吸引到一些有技术追求的人, 能把他们用好, 少收到一些<code>混差</code>(boss拍脑袋, 产品献媚方案)的影响. 说不定还能让团队走的更远</p><h2 id="心理"><a href="#心理" class="headerlink" title="心理"></a>心理</h2><p>人心齐, 泰山移.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前前言&quot;&gt;&lt;a href=&quot;#前前言&quot; class=&quot;headerlink&quot; title=&quot;前前言&quot;&gt;&lt;/a&gt;前前言&lt;/h2&gt;&lt;p&gt;还没写完, 今年有了新的感悟, 想好了再补充&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://mactive.github.io/tags/javascript/"/>
    
      <category term="NodeJS" scheme="http://mactive.github.io/tags/NodeJS/"/>
    
      <category term="C++" scheme="http://mactive.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>我厂项目开发流程</title>
    <link href="http://mactive.github.io/2017/07/21/meituan-workflow/"/>
    <id>http://mactive.github.io/2017/07/21/meituan-workflow/</id>
    <published>2017-07-21T01:04:44.000Z</published>
    <updated>2020-12-28T00:27:05.586Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一句话经验</strong><br>说实话,这个管理风格并不明显, 不算敏捷, 甚至有些繁琐, 但是却是风险最低的. 在多方(UI,UE,RD,PM,QA,业务) 合作的过程中这样协作方式还是能保障大家则责权清楚(到底是谁的锅),还是很有必要的. </p><a id="more"></a><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>下面的表格,会对角色, 动作, 互相的依赖 做一个梳理</p><ul><li>UI: User Interface 美工</li><li>UE: User Experience 交互</li><li>RD: Research Development 研发</li><li>PM: Production Manager 产品</li><li>QA: Quality Assurance 测试</li><li>BD: Business Development 业务</li></ul><h2 id="表1-时序动作图"><a href="#表1-时序动作图" class="headerlink" title="表1 时序动作图"></a>表1 时序动作图</h2><table><thead><tr><th>阶段</th><th>角色</th><th>动作</th><th>指标</th></tr></thead><tbody><tr><td>酝酿期</td><td>PM</td><td>根据需求理解PRD草稿</td><td></td></tr><tr><td></td><td>业务</td><td>业务需求</td><td>有些需求没有业务参与, 直接来自产品或CEO</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>评估期</td><td>PM</td><td>输出PRD文档, 根据评估意见调整修改PRD</td><td></td></tr><tr><td></td><td>RD</td><td>评估PRD, 技术实现评估 技术预演</td><td></td></tr><tr><td></td><td>UE</td><td>根据PRD给出UE交互图, 参考原有UE规范</td><td></td></tr><tr><td></td><td>UI</td><td>在RD评估完之后, 制作</td><td></td></tr><tr><td>启动期</td><td>PM</td><td>产品的使用预期, 如果通过埋点证明预期</td><td>DAU,人力节省等</td></tr><tr><td></td><td>RD1</td><td>给出人日估算(根据项目复杂度和探索性预留10%-20%的弹性时间)</td><td>一定要考虑UI和UE才能给出人日评估. 探索性: 新项目, 新的知识点, 新技术方案</td></tr><tr><td></td><td>RD2</td><td>和研发各方确认后给出排期, 排期包括 开发,联调,提测,上线时间点</td><td>复杂度: 协作要求高的地方. 实现难度高的地方</td></tr><tr><td></td><td>业务</td><td>启动会</td><td>阐述开发目的, 给大家画饼</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>开发期</td><td>RD后端</td><td>和前端一起约定接口文档和数据类型</td><td></td></tr><tr><td></td><td>RD前端</td><td>搭建项目, mock数据, 组件化开发</td><td>原则: 先难后易, 先主干后细节</td></tr><tr><td></td><td>PM</td><td>对有争议实现细节给出可执行方案</td><td>明确产品的开发目的</td></tr><tr><td></td><td>RD</td><td>负责的系统需要有设计文档, 复杂的项目需要有结构文档</td><td></td></tr><tr><td>联调</td><td>RD</td><td>部署dev环境</td><td>前后端,或依赖端之间联调</td></tr><tr><td></td><td>QA</td><td>提出测试用例并组织大家评估</td><td>测试用例基于PRD, 是可以修改的. 如果有争议,RD可以找产品最终决定, 要带上QA一起讨论</td></tr><tr><td></td><td>RD</td><td>根据测试用例,自测通过</td><td>并且冒烟通过</td></tr><tr><td>提测</td><td>RD</td><td>主R发提测邮件</td><td>注明测试地址和测试方法</td></tr><tr><td></td><td>QA</td><td>部署test/beta环境, 并测试</td><td>有时候环境部署是RD来完成的,或者协助的</td></tr><tr><td></td><td>PM</td><td>产品验收</td><td>对比产品方案</td></tr><tr><td></td><td>UI</td><td>UI验收</td><td>对比实现效果</td></tr><tr><td></td><td>QA</td><td>二次验收</td><td>对修复的bug进行验收, flow操作</td></tr><tr><td></td><td>RD</td><td>根据QA提出的bug进行修改, 如果是产品方案的瑕疵可以将bug转给产品</td><td>如果有争议如要产品介入, 最好每天碰一下</td></tr><tr><td></td><td>RD</td><td>合并分支, review代码</td><td></td></tr><tr><td>上线</td><td>RD</td><td>发布stage环境测试</td><td></td></tr><tr><td></td><td>QA</td><td>二次回归</td><td></td></tr><tr><td></td><td>RD</td><td>发布production环境</td><td></td></tr><tr><td></td><td>PM&amp;QA</td><td>线上回归</td><td></td></tr><tr><td></td><td>灰度上线</td><td>hotfix</td><td></td></tr><tr><td></td><td>正式上线</td><td>全量</td><td></td></tr><tr><td>总结期</td><td>PM</td><td>效果评估</td><td>如果效果不好, RD下次再排期的时候可以找PM多理论一下</td></tr><tr><td></td><td>RD</td><td>总结评估和开发过程中的碰到的问题和坑, 下一期塞进去些技术需求</td><td>整理wiki和分享</td></tr><tr><td></td><td>RD</td><td>主R组织大家讨论管理和协作方面的问题</td><td>整理wiki和分享</td></tr></tbody></table><h2 id="表1-1-排期表"><a href="#表1-1-排期表" class="headerlink" title="表1.1 排期表"></a>表1.1 排期表</h2><p><img src="/images/workflow_meituan_1.png" alt></p><h2 id="表2-依赖关系路径"><a href="#表2-依赖关系路径" class="headerlink" title="表2 依赖关系路径"></a>表2 依赖关系路径</h2><h3 id="估时-amp-排期"><a href="#估时-amp-排期" class="headerlink" title="估时 &amp; 排期"></a>估时 &amp; 排期</h3><p><code>PRD清晰且明确</code> -&gt; <code>UI按照PRD来</code> -&gt; <code>UE过程明确</code> -&gt; <code>RD预演了技术</code> -&gt; <code>没有并行项目干扰</code> -&gt; <code>给出估时</code> -&gt; <code>各方确认时间点</code> -&gt; <code>确认排期</code></p><h3 id="提测"><a href="#提测" class="headerlink" title="提测"></a>提测</h3><p><code>前端开发完毕</code> -&gt; <code>前端之间联调完毕</code> -&gt; <code>后端开发完毕</code> -&gt; <code>后端之间API和服务化开发完毕</code> -&gt; <code>前/后端联调完毕</code> -&gt; <code>测试环境部署完毕</code> -&gt; <code>确认了测试用例</code> -&gt; <code>自测完成</code> -&gt; <code>冒烟完成</code> -&gt;  <code>提测</code> </p><h2 id="表3-异常处理"><a href="#表3-异常处理" class="headerlink" title="表3 异常处理"></a>表3 异常处理</h2><table><thead><tr><th>异常</th><th>处理</th><th>归类</th></tr></thead><tbody><tr><td>prd改动</td><td>周知RD和QA, RD默默的掏出一把菜刀来</td><td>开发过程中</td></tr><tr><td>时间不够用</td><td>申请延期或者找空余的人力来补充</td><td>开发过程中</td></tr><tr><td>妈的方案想简单了</td><td>换个方案,可能不完美但是work</td><td>开发过程中</td></tr><tr><td>环境有问题,有依赖别的开发组</td><td>封闭开发或者加班搞</td><td>提测过程</td></tr><tr><td>某个点实现和PRD有严重出入</td><td>PRD可能模棱两可, 其实最后就看谁强势,谁更好被说服</td><td>提测过程</td></tr></tbody></table><h2 id="思考所谓管理"><a href="#思考所谓管理" class="headerlink" title="思考所谓管理"></a>思考所谓管理</h2><p>###管理的Loop</p><p><code>总结</code> -&gt; <code>形成SOP</code> -&gt; <code>推动执行</code> -&gt; <code>收集问题</code> -&gt; <code>改进</code> -&gt; <code>总结</code></p><p>简单说就是讲事情分成若干个环节, 制定每个环节的标注, 提前告知每个环节可能出现的风险.</p><p>在一堆不(各)同(怀)角(鬼)色(胎)的人之间达成共识, 处理纠纷. 最后得出一个妥协后的产品.<br>有了标准的生命周期之后, 可以推出简化版的SOP和复杂版的SOP供大家执行.</p><p>跟开发一个框架Framework差不多, 在性能和成本之间不停的取舍. 为今后的使用总结经验</p><p><strong>SOP</strong>, Standard Operating Procedures, 标准作业程序</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;一句话经验&lt;/strong&gt;&lt;br&gt;说实话,这个管理风格并不明显, 不算敏捷, 甚至有些繁琐, 但是却是风险最低的. 在多方(UI,UE,RD,PM,QA,业务) 合作的过程中这样协作方式还是能保障大家则责权清楚(到底是谁的锅),还是很有必要的. &lt;/p&gt;
    
    </summary>
    
    
      <category term="workflow" scheme="http://mactive.github.io/tags/workflow/"/>
    
      <category term="meituan" scheme="http://mactive.github.io/tags/meituan/"/>
    
      <category term="management" scheme="http://mactive.github.io/tags/management/"/>
    
  </entry>
  
  <entry>
    <title>人生如狗, 梦想彼岸</title>
    <link href="http://mactive.github.io/2017/07/17/life-dog-dream/"/>
    <id>http://mactive.github.io/2017/07/17/life-dog-dream/</id>
    <published>2017-07-17T02:08:44.000Z</published>
    <updated>2020-12-28T00:27:05.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="养狗"><a href="#养狗" class="headerlink" title="养狗"></a>养狗</h2><p>不出所料,在孩子的要求下和我的纵容下. 最近养了一只<a href="https://zh.wikipedia.org/wiki/%E5%B0%8F%E7%8D%B5%E7%8A%AC" target="_blank" rel="noopener">狗</a>, 比格犬, 小猎犬, Beagle, 全称 米格鲁猎兔犬. 其实挺燥的一只狗, 不过安静的时候也很安静. 比较通人性, 也还算听话, 有一定的主见. 见了其他狗都不怂.</p><p>养了几日发现小狗跟小孩真的一样, 特指小孩小的时候. 需要陪伴, 不知饥饱, 贪玩任性, 记吃不记打. 玩起来一阵风, 东跑西颠, 累了就往地上一疼, 姿势是非随意. 果然是猎犬的后代. 生活非常洒脱. </p><h2 id="MAX"><a href="#MAX" class="headerlink" title="MAX"></a>MAX</h2><p>忘了介绍一下了, 名叫Max, 我们家的第四号成员.<br><a href="https://twitter.com/moodomac/status/886757254627643392" target="_blank" rel="noopener">Max is my name</a></p><p>偶然见看到一句,男人如狗, 女人如猫. 狗狗就是一次次的相信世界是善良的, 傻乎乎的追逐自己看似虚幻的目标(一次次的捡回木棍或球), 用自己的一腔热血和坚持赢得世界的尊重. 男人一样, 需要向世界证明自己, 不惜代价的为了金钱权力推动着历史前进, 然后沉迷于女色. 狗狗也是, 一见面打招呼就是问问头, 闻闻屁股, 同性的话互相扑一下, <del>异性的话就绕到后面开始ooxx了,</del> 拉都拉不走. 想想弗洛伊德的理论, 也就了解了.</p><p>猫咪则是一副高冷的样子, 对时间种种挑挑剔剔, 对铲屎官们也没有一点尊重. 但是爱上镜, 爱骗人, 喜欢找各种舒适的地方一趟. 没有忠诚可言, 谁给吃的跟谁走, 哈哈. 但是有好处, 爱干净, 爱卖萌, 知道分寸. 以上逐条形容有些妹子在合适不过. </p><p>但是猫狗中也有例外, 有些狗狗也很(follow it’s heart)怂, 有些猫咪也比较有性格.近些年民智逐渐开启, 大家的活法也不再是千篇一律了, 越来越多的人觉醒, 不再做现实的努力. 既然殊途同归(老了的下场都差不多), 不入年轻的时候尽量活出自己想要的样子.身边已经有很多这样的例子. 也有很多书和电影作品鼓舞人们. 另外最近看了一些书, 在历史上留下印记的前人们, 也多不是按部就班之人.</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>有的时候我们会羡慕那些成功人士的成功生活, 但那些可能是属于少数人, 而且背后有隐藏的背景或者惨烈的代价. 大多数人只能在力所能及的范围内, 小心的保护自己内心中的小火种. 保护他不会熄灭, 可能火光会微弱, 但只要心不死, 都有复燃的可能性. 一旦到达合适的时间,(间隔年, 换工作,退休等). 人们就会纷纷离开自己的舒适区, 寻找彼岸, 安放自己梦想,和志同道合的人一起, 为其盖起宏伟的宫殿.</p><p>最后安利一步电影<a href="https://movie.douban.com/subject/26811587/" target="_blank" rel="noopener">大护法-政治隐喻,血腥暴力</a>.对抗极权千万不要心慈手软 —— 一切只是刚刚开始</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;养狗&quot;&gt;&lt;a href=&quot;#养狗&quot; class=&quot;headerlink&quot; title=&quot;养狗&quot;&gt;&lt;/a&gt;养狗&lt;/h2&gt;&lt;p&gt;不出所料,在孩子的要求下和我的纵容下. 最近养了一只&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B
      
    
    </summary>
    
    
      <category term="Life" scheme="http://mactive.github.io/tags/Life/"/>
    
      <category term="Dream" scheme="http://mactive.github.io/tags/Dream/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS 和 C++ -- 低(前)端程序员为什么要学C++</title>
    <link href="http://mactive.github.io/2017/04/20/nodejs-addon-cpp/"/>
    <id>http://mactive.github.io/2017/04/20/nodejs-addon-cpp/</id>
    <published>2017-04-20T00:59:00.000Z</published>
    <updated>2020-12-28T00:27:05.586Z</updated>
    
    <content type="html"><![CDATA[<p>先来个简单的公式</p><h2 id="NodeJS-Foundation-V8-Engine-JS-API"><a href="#NodeJS-Foundation-V8-Engine-JS-API" class="headerlink" title="NodeJS = Foundation + V8 Engine + JS API"></a>NodeJS = Foundation + V8 Engine + JS API</h2><p>如果我们仔细看一下Node的源码,其中有23.8%的C++,5.6%的C,还有64.5%的JS.<br><code>Foundation</code>中包含几大核心, File(文件操作),Network(网络),Event(事件驱动),Stream(流的概念),Module(模块系统). 这几块无一不是C/C++实现的.JS的解释器V8Engine更是C/C++实现的,别忘了Chrome可能是世界上最大的C/C++项目了.</p><p><code>Foundtion</code>既然是C++实现的,那么在各个操作系统上的实现肯定不一样了.你可以想想一下读取Linux上的文件和Win10上的文件的C++代码肯定不一样, 而且你的C++代码需要调用操作系统的C++API才能实现功能. 据我所知,大部分的操作系统都是用C/C++写成的.</p><p>JS API可能是通用的,因为Node为我们实现了一套C-&gt;JS的bridge,这样Node开发组的同学就可以用JS做一些API的封装和抽象.而社区里写npm package的同学可以只使用JS API 就可以做一些工具包了.  因为<code>Foundation</code> 和 <code>V8Engine</code> 已经接受了多年业界的考验. 在此感谢Google和社区默默贡献的C/C++程序员.</p><a id="more"></a><p>同时Node开放了他们自己使用的Bridge,可以让社区也写一些<a href="https://nodejs.org/api/addons.html" target="_blank" rel="noopener">C/C++ Addon</a>.提供了类似<code>NODE_SET_METHOD</code>,<code>NODE_MODULE</code>的C宏供开发的时候调用,官方给了一些实例教你如何在JS和C++之间传递Object和 Funciton,构造Function Factory,以及基本的数值转换.是不是感觉个ReactNative提供的Bridge非常的类似.</p><blockquote><p>可能有同学有疑问,为什么有的时候NodeJS需要C++, 或者你是不是经常碰到<code>npm i</code>的时候特别慢.或者卡在node-gyp的什么地方. npm i 慢有两个原因一个是网速,一个是你在用你的电脑build C++代码.为啥要build C++,还是因为慢,你没能下载下来node-pre-gyp编译好的能在你系统上跑的C++二进制包(因为GFW),那就需要你本地打包. 可能有同学问为啥我需要C++呢, 比如因为存储,用到sqlite3,因为图形处理用到ffmpeg等等. </p></blockquote><p>下面我们讲讲node-gyp和他引出来的东西</p><h2 id="node-gyp-和-electron"><a href="#node-gyp-和-electron" class="headerlink" title="node-gyp 和 electron"></a>node-gyp 和 electron</h2><p><img src="/images/node_addon_1.png" alt></p><p>electron其实也是一个Framework,他把你开发桌面应用的可能用到东西帮你做好了,比如Menu(菜单),Window(窗体)等等.当然也需要社区帮你抹平各个操作系统上的差异.</p><ul><li>拓展了sandbox(更多的系统操作的权限)</li><li>使得NodeJS不止做服务器端应用.而且可以做桌面应用.</li><li>Make JS great again with standing on the C++’s shoulder</li></ul><p>nw.js 是做这件事的先驱,不过现在不再继续维护,他两个可以说是一脉相承,都有人使用.</p><h2 id="C-或者其他编译型语言的过程"><a href="#C-或者其他编译型语言的过程" class="headerlink" title="C++ 或者其他编译型语言的过程"></a>C++ 或者其他编译型语言的过程</h2><p><img src="/images/node_addon_2.png" alt></p><p>静态语言都离不开这些步骤.在Compile的时候可能会因为你自己写的语法而报错.在Link的时候经常会找不到相应的库而不能执行下去. Debug和run的区别无非就是加入Symbol,让编译器在报错的时候能告诉你错误出在了哪一行,他的上下文之类的,方便你debug.你最后Release的版本必然是不包含symbol的. 一般一个可执行的Binary文件都会配一个symbol文件. 类似xx.min.js + xx.min.js.map</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>chrome 50之后不再支持winXP, 应该跟XP上的C++执行器有关系.因为微软可能已经不再维护以WindowNT5为版本的winXP了.</li><li>如何你要做WinXP的客户端(比如我厂),那么你只能使用 nw.js &lt;= 0.14.7的版本</li><li>$: file addon.node 可以再mac上查看文件的类型,二进制文件可以知道软件和硬件架构</li></ul><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><ul><li>这个文章配合的<a href="https://github.com/mactive/my_node_addon" target="_blank" rel="noopener">github</a></li><li>结合使用 nan 和 binding 的 addon <a href="https://github.com/nodejs/node-addon-examples" target="_blank" rel="noopener">github</a></li><li><a href="https://github.com/nodejs/node" target="_blank" rel="noopener">NodeJS</a></li><li><a href="https://github.com/nodejs/node-gyp" target="_blank" rel="noopener">node-gyp</a></li></ul><h2 id="推荐一些C-的学习资源"><a href="#推荐一些C-的学习资源" class="headerlink" title="推荐一些C++的学习资源"></a>推荐一些C++的学习资源</h2><ul><li><a href="https://v8docs.nodesource.com/node-7.4/" target="_blank" rel="noopener">V8 文档</a> 配合 <a href="https://nodejs.org/api/addons.html" target="_blank" rel="noopener">C/C++ Addon</a> 来看</li><li><a href="http://www.runoob.com/cplusplus/cpp-tutorial.html" target="_blank" rel="noopener">C++中文菜鸟教程</a></li><li><a href="http://www.learncpp.com/" target="_blank" rel="noopener">www.learncpp.com</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来个简单的公式&lt;/p&gt;
&lt;h2 id=&quot;NodeJS-Foundation-V8-Engine-JS-API&quot;&gt;&lt;a href=&quot;#NodeJS-Foundation-V8-Engine-JS-API&quot; class=&quot;headerlink&quot; title=&quot;NodeJS = Foundation + V8 Engine + JS API&quot;&gt;&lt;/a&gt;NodeJS = Foundation + V8 Engine + JS API&lt;/h2&gt;&lt;p&gt;如果我们仔细看一下Node的源码,其中有23.8%的C++,5.6%的C,还有64.5%的JS.&lt;br&gt;&lt;code&gt;Foundation&lt;/code&gt;中包含几大核心, File(文件操作),Network(网络),Event(事件驱动),Stream(流的概念),Module(模块系统). 这几块无一不是C/C++实现的.JS的解释器V8Engine更是C/C++实现的,别忘了Chrome可能是世界上最大的C/C++项目了.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Foundtion&lt;/code&gt;既然是C++实现的,那么在各个操作系统上的实现肯定不一样了.你可以想想一下读取Linux上的文件和Win10上的文件的C++代码肯定不一样, 而且你的C++代码需要调用操作系统的C++API才能实现功能. 据我所知,大部分的操作系统都是用C/C++写成的.&lt;/p&gt;
&lt;p&gt;JS API可能是通用的,因为Node为我们实现了一套C-&amp;gt;JS的bridge,这样Node开发组的同学就可以用JS做一些API的封装和抽象.而社区里写npm package的同学可以只使用JS API 就可以做一些工具包了.  因为&lt;code&gt;Foundation&lt;/code&gt; 和 &lt;code&gt;V8Engine&lt;/code&gt; 已经接受了多年业界的考验. 在此感谢Google和社区默默贡献的C/C++程序员.&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://mactive.github.io/tags/javascript/"/>
    
      <category term="NodeJS" scheme="http://mactive.github.io/tags/NodeJS/"/>
    
      <category term="C++" scheme="http://mactive.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Vue 组件开发心得(1)</title>
    <link href="http://mactive.github.io/2017/03/24/vue-component-1/"/>
    <id>http://mactive.github.io/2017/03/24/vue-component-1/</id>
    <published>2017-03-24T09:07:44.000Z</published>
    <updated>2020-12-28T00:27:05.587Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一句话经验</strong></p><h2 id="computed干什么用"><a href="#computed干什么用" class="headerlink" title="computed干什么用"></a>computed干什么用</h2><ol><li><p>动态数据计算,不确定数据有没有</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">computedTagId: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  vm = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 如果第三个品类选择不存在, 那么是-1</span></span><br><span class="line">  <span class="keyword">if</span>(vm.tagIdLevel3 == <span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> vm.tagIdLevel2;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> vm.tagIdLevel3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>动态dom选择,不确定dom节点没有没有</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$licenceDate: <span class="function"><span class="params">()</span> =&gt;</span> $(<span class="string">".licence_validateDate"</span>),</span><br><span class="line">$speDate: <span class="function"><span class="params">()</span> =&gt;</span> $(<span class="string">".spe_pmt_validateDate"</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="refs"><a href="#refs" class="headerlink" title="$refs"></a>$refs</h2><ol><li>不同组件之间的 \$refs 不混用, 可以重名, 你也可以访问到父级的 \$refs 可以理解为是个树的结构<br> $refs 是个Object, 可以遍历. 可以.xx 和 [xx]</li><li>ref 放在什么东西上就是什么, reference的意思</li></ol><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// this.<span class="variable">$refs</span>[<span class="string">'username'</span>] 就是个dom对象</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">dom</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">// this.<span class="variable">$refs</span>.city 就是个vue组件(vue <span class="keyword">instance</span>)</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">auto-select</span> <span class="attr">ref</span>=<span class="string">"city"</span>&gt;</span><span class="tag">&lt;/<span class="name">auto-select</span>&gt;</span></span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="set"><a href="#set" class="headerlink" title="$set"></a>$set</h2><ol><li>不允许直接往data根对象中$set不存在的属性, 可以$set 到 this.someObject</li><li>如果$set一个Object,Object中无论有几个层级, vue都会为每个对象建立 set和get方法</li><li>就算是对象是后$set的,对于子属性的watch方法也是可以呗触发的<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a 在data中初始化了, 必须是个Object对象, 如果a.b 也初始化了</span></span><br><span class="line"><span class="comment">// $set会覆盖a.b 并深度遍历b中所有的子属性, 并为他们建立set和get方法</span></span><br><span class="line">mounted: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.$<span class="keyword">set</span>(<span class="keyword">this</span>.a, <span class="string">'b'</span>, &#123;</span><br><span class="line">   name: &#123;</span><br><span class="line">     first: <span class="string">'Meng'</span>,</span><br><span class="line">     last: <span class="string">'Mac'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age: <span class="number">121</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="mixin-用来做什么"><a href="#mixin-用来做什么" class="headerlink" title="mixin 用来做什么"></a>mixin 用来做什么</h2><p>和业务不强相关又不能独立变成组件的东西.<br>写 mixin 的时候可以,拿到组件的data和prop,可以在完整的生命周期中做事情. 基本上可以理解extend 到 vue的options 中去. 不过有merge优先级选择 <code>Vue.config.optionMergeStrategies</code></p><ul><li>监控, log</li><li>性能统计</li><li>每个组件都需要包含的内容, uuid等, 组件通讯等</li><li>将过大的.vue文件拆成多个 mixin 方便重构 </li></ul><h2 id="directive-用来做什么"><a href="#directive-用来做什么" class="headerlink" title="directive 用来做什么"></a>directive 用来做什么</h2><p>一些dom event相关的事情, 也是配合这组件取用, 需要实现有限的hook funcion. 适合移动端手势, 统一滚动等等</p><ul><li>vue-tap</li><li>vue-focus </li><li>vue-clickaway</li><li>vue-scroll</li></ul><h2 id="little-tips"><a href="#little-tips" class="headerlink" title="little tips"></a>little tips</h2><h3 id="tips1"><a href="#tips1" class="headerlink" title="tips1"></a>tips1</h3><p>如果你想传入的props 不是string类型,记得加 <code>v-bind:</code> 或者简写成 <code>:</code></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 如果写成 searchCount=<span class="string">"2"</span>, 那么 组件内部 </span><br><span class="line"><span class="regexp">//</span> <span class="keyword">typeof</span> <span class="keyword">this</span>.searchCount == String</span><br><span class="line">&lt;amap-search </span><br><span class="line"> :searchCount=<span class="string">"2"</span></span><br><span class="line"> :autoConfirm=<span class="string">"false"</span></span><br><span class="line"> :useClick=<span class="string">"true"</span></span><br><span class="line"> title=<span class="string">"amap title"</span></span><br><span class="line"> @userInput=<span class="string">"handleUserInput"</span></span><br><span class="line"> @pickedLocation=<span class="string">"handlePickedLocation"</span>&gt;</span><br><span class="line">&lt;/amap-search&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;一句话经验&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;computed干什么用&quot;&gt;&lt;a href=&quot;#computed干什么用&quot; class=&quot;headerlink&quot; title=&quot;computed干什么用&quot;&gt;&lt;/a&gt;computed干什么用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态数据计算,不确定数据有没有&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;computedTagId: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  vm = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 如果第三个品类选择不存在, 那么是-1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(vm.tagIdLevel3 == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; vm.tagIdLevel2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; vm.tagIdLevel3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态dom选择,不确定dom节点没有没有&lt;/p&gt;
&lt;figure class=&quot;highlight coffeescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$licenceDate: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; $(&lt;span class=&quot;string&quot;&gt;&quot;.licence_validateDate&quot;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$speDate: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; $(&lt;span class=&quot;string&quot;&gt;&quot;.spe_pmt_validateDate&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;refs&quot;&gt;&lt;a href=&quot;#refs&quot; class=&quot;headerlink&quot; title=&quot;$refs&quot;&gt;&lt;/a&gt;$refs&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;不同组件之间的 \$refs 不混用, 可以重名, 你也可以访问到父级的 \$refs 可以理解为是个树的结构&lt;br&gt; $refs 是个Object, 可以遍历. 可以.xx 和 [xx]&lt;/li&gt;
&lt;li&gt;ref 放在什么东西上就是什么, reference的意思&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// this.&lt;span class=&quot;variable&quot;&gt;$refs&lt;/span&gt;[&lt;span class=&quot;string&quot;&gt;&#39;username&#39;&lt;/span&gt;] 就是个dom对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ref&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;username&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dom&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// this.&lt;span class=&quot;variable&quot;&gt;$refs&lt;/span&gt;.city 就是个vue组件(vue &lt;span class=&quot;keyword&quot;&gt;instance&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;auto-select&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ref&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;city&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;auto-select&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://mactive.github.io/tags/javascript/"/>
    
      <category term="Vue" scheme="http://mactive.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 朝花夕拾 -- 3 浏览器中JavaScript的好基友</title>
    <link href="http://mactive.github.io/2017/03/04/JavaScript-dawn-blosson-3/"/>
    <id>http://mactive.github.io/2017/03/04/JavaScript-dawn-blosson-3/</id>
    <published>2017-03-04T02:15:05.000Z</published>
    <updated>2020-12-28T00:27:05.583Z</updated>
    
    <content type="html"><![CDATA[<p>最近面试发现很多新人对DOM Event甚至DOM 都不怎么了解.在此科普一下<br>浏览器厂商和W3C标准为广大的JS开发者准备了写什么. 浏览器开发是业界公认的开发难度仅次于操作系统的项目,google和mozilla都排出了顶级的工程师参与开发,并诞生了 webkit和v8 engine等伟大的开源项目应用在PC和移动端,微软也从标准的阻碍者逐渐变成了标准追随者(⊙﹏⊙)b</p><h2 id="DOM-Document-Object-Model"><a href="#DOM-Document-Object-Model" class="headerlink" title="DOM Document Object Model"></a>DOM Document Object Model</h2><blockquote><p>DOM 并不只是针对 JavaScript 的,很多别的语言也都实现了 DOM.</p></blockquote><ul><li>DOM0: 历史基准点并不存在</li><li>DOM1: 映射文档的结构, DOM Core + DOM HTML</li><li>DOM2: 在DOM1的基础上增加了</li><li><ul><li>DOM Event: 定义了事件和事件处理的接口</li></ul></li><li><ul><li>DOM Style: 定义了基于 CSS 为元素应用样式的接口</li></ul></li><li><ul><li>DOM Traversal and Range: 定义了遍历和操作文档树的接口</li></ul></li><li>DOM3: 引入了以统一方式加载和保存文档的方法和验证文档的方法. DOM3 级也对 DOM 核心进行了扩展</li></ul><p>基本也反应了一个HTML语言和CSS语言的发展阶段, 各个浏览器大厂在规范下做自己的实现.</p><blockquote><p>SVG,MathML,SMIL 都属于其他DOM标准,看浏览器的支持情况了.</p></blockquote><a id="more"></a><h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读:"></a>扩展阅读:</h3><p>DOM Event: <a href="https://www.w3schools.com/jsref/dom_obj_event.asp" target="_blank" rel="noopener">HTML DOM Events</a>, 开头一段话非常好解释了什么事HTML DOM Events. Chrome浏览器的开发工程师就是围绕找DOM的几大方向,V8引擎,和一些开发调试工具,插件环境去做C/C++开发.</p><blockquote><p>HTML DOM Events 允许 JavaScript 注册不同的EventHandlers到元素上. Events通常结合函数一起使用, 函数本身不会马上执行直到事件被触发, 比如用户点击了一个元素或者拖拽了一个元素或者从一个input上blur了出来.<br>Tip: The event model was standardized by the W3C in DOM Level 2. DOM Level 2 就是上文中提到的 DOM2</p></blockquote><p>分为这么几大类</p><ul><li>Mouse Events</li><li>Keyboard Events</li><li>Frame/Object Events</li><li>Form Events</li><li>Drag Events</li><li>Clipboard Events</li><li>Print Events</li><li>Touch Events</li><li>…更多</li></ul><p><strong>每种 Event 都应对应的 的MouseEvent Object</strong>,方便你能拿到具体的值.很多方法名都是on开头.</p><p>传统的写法<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span> <span class="attr">onclick</span>=<span class="string">"myFunction(this, 'red')"</span>&gt;</span>Click me to change my text color.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">(elmnt,clr)</span> </span>&#123;</span></span><br><span class="line">    elmnt.style.color = clr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>使用EventListener,无需在html上面将DomEvent 和 JS function 做绑定.<br>这一直接在js中找了element然后添加event</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="BOM-Browser-Object-Model"><a href="#BOM-Browser-Object-Model" class="headerlink" title="BOM - Browser Object Model"></a>BOM - Browser Object Model</h2><ul><li>window: 移动、缩放和关闭浏览器窗口的功能</li><li>navigator: 浏览器的详细信息,浏览器名,系统平台,插件等</li><li>location: 页面的URI的具体参数,协议,接口,query</li><li>screen: 用户显示器分辨率详细信息</li><li>history: 浏览历史和操作</li><li>cookies: 后来又扩展出了 localStorage,PWA渐进等概念</li><li>XMLHttpRequest: 网络请求和接受. Ajax的核心,IE当时搞了ActiveXObject</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近面试发现很多新人对DOM Event甚至DOM 都不怎么了解.在此科普一下&lt;br&gt;浏览器厂商和W3C标准为广大的JS开发者准备了写什么. 浏览器开发是业界公认的开发难度仅次于操作系统的项目,google和mozilla都排出了顶级的工程师参与开发,并诞生了 webkit和v8 engine等伟大的开源项目应用在PC和移动端,微软也从标准的阻碍者逐渐变成了标准追随者(⊙﹏⊙)b&lt;/p&gt;
&lt;h2 id=&quot;DOM-Document-Object-Model&quot;&gt;&lt;a href=&quot;#DOM-Document-Object-Model&quot; class=&quot;headerlink&quot; title=&quot;DOM Document Object Model&quot;&gt;&lt;/a&gt;DOM Document Object Model&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;DOM 并不只是针对 JavaScript 的,很多别的语言也都实现了 DOM.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;DOM0: 历史基准点并不存在&lt;/li&gt;
&lt;li&gt;DOM1: 映射文档的结构, DOM Core + DOM HTML&lt;/li&gt;
&lt;li&gt;DOM2: 在DOM1的基础上增加了&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;DOM Event: 定义了事件和事件处理的接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;DOM Style: 定义了基于 CSS 为元素应用样式的接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;DOM Traversal and Range: 定义了遍历和操作文档树的接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DOM3: 引入了以统一方式加载和保存文档的方法和验证文档的方法. DOM3 级也对 DOM 核心进行了扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本也反应了一个HTML语言和CSS语言的发展阶段, 各个浏览器大厂在规范下做自己的实现.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SVG,MathML,SMIL 都属于其他DOM标准,看浏览器的支持情况了.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://mactive.github.io/tags/JavaScript/"/>
    
      <category term="DawnBlossom" scheme="http://mactive.github.io/tags/DawnBlossom/"/>
    
      <category term="Series" scheme="http://mactive.github.io/tags/Series/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 朝花夕拾 -- 2 Require.JS 定义和发现机制</title>
    <link href="http://mactive.github.io/2017/02/23/JavaScript-dawn-blosson-2/"/>
    <id>http://mactive.github.io/2017/02/23/JavaScript-dawn-blosson-2/</id>
    <published>2017-02-23T02:40:35.000Z</published>
    <updated>2020-12-28T00:27:05.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Require-JS-定义和发现机制"><a href="#Require-JS-定义和发现机制" class="headerlink" title="Require.JS 定义和发现机制"></a>Require.JS 定义和发现机制</h2><p>很多jquery插件的头部都写成了这种样式,这种叫UMD,它支持AMD和CommonJS规范，同时还支持古老的全局模块模式。</p><p><a href="http://blog.gejiawen.com/2015/11/03/what-is-amd-cmd-commonjs-umd/" target="_blank" rel="noopener">关于AMD,CMD,CommonJS及UMD规范</a>可以看这里.require.js和angular自带的使用的是标准的AMD方式.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">"object"</span> &amp;&amp; exports &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="built_in">module</span> &amp;&amp; <span class="built_in">module</span>.exports === exports) &#123;</span><br><span class="line">        <span class="comment">// Browserify. Attach to jQuery module.</span></span><br><span class="line">        factory(<span class="built_in">require</span>(<span class="string">"jquery"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line"><span class="comment">// AMD. Register as an anonymous module.</span></span><br><span class="line">define([<span class="string">'jquery'</span>], factory);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Browser globals</span></span><br><span class="line">factory(jQuery);</span><br><span class="line">&#125;</span><br><span class="line">&#125;(<span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line"><span class="comment">//插件主体 一堆堆function</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>moment.js 的头部则写成了这样,和上面都是UMD方案,都是为了让开发者在node端,浏览器端,浏览器+loader的情况下都可以使用到自己的模块.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">global, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">typeof</span> exports === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> ? <span class="built_in">module</span>.exports = factory() :</span><br><span class="line">    <span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd ? define(factory) :</span><br><span class="line">    global.moment = factory()</span><br><span class="line">&#125;(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="string">'use strict'</span>;</span><br><span class="line"><span class="comment">// function 1</span></span><br><span class="line"><span class="comment">// …</span></span><br><span class="line"><span class="comment">// function n</span></span><br><span class="line"><span class="keyword">return</span> moment;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h2 id="因为"><a href="#因为" class="headerlink" title="因为"></a>因为</h2><ol><li>如果都是用define定义的模块,那么不用在shim</li><li>如果不是用define写的模块,又有依赖,比如 jquery.datepair 依赖 jquery,需要写在shim中.</li></ol><p><strong>shim的英文是垫片的意思,有类似转接环的概念.将非AMD方式定义的组件转义过来</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">shim: &#123;</span><br><span class="line">    <span class="string">'jquery.datepair'</span>:&#123;</span><br><span class="line">      <span class="string">'deps'</span>: [’jquery’,<span class="string">'datepair’] //需要写明依赖</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure><h3 id="加载非规范的模块"><a href="#加载非规范的模块" class="headerlink" title="加载非规范的模块"></a>加载非规范的模块</h3><p>理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。<br>那么，require.js是否能够加载非规范的模块呢？<br>回答是可以的。</p><p>这样的模块在用require()加载之前，要先用require.config()方法的shim属性专门用来配置不兼容的模块。<br>举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。</p><p>deps[] 是他的的依赖,dependencies 的意思<br>shim的英文是垫片的意思,有类似转接环的概念.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">shim: &#123;</span><br><span class="line"><span class="string">'underscore'</span>:&#123;</span><br><span class="line">exports: <span class="string">'_'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'backbone'</span>: &#123;</span><br><span class="line">deps: [<span class="string">'underscore'</span>, <span class="string">'jquery'</span>],</span><br><span class="line">exports: <span class="string">'Backbone'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'jquery.scroll'</span>: &#123;</span><br><span class="line">　　deps: [<span class="string">'jquery'</span>],</span><br><span class="line">　　exports: <span class="string">'jQuery.fn.scroll'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>require.js 几个大概念</p><ol><li>config() 配置依赖</li><li>define() 定义模块</li><li>require() 使用模块</li></ol><p>define 一般自己用, 先声明配置,然后下面使用配置. 而且define一个模块的时候也可以引入依赖包,可以返回对象或者funtion,也可以给模块define一个名字</p><ul><li>Definition Functions with dependencies</li><li>Definition a Module as a Functions or Object (Function 还是 Object 看业务需要,Object有的时候子对象也是function)</li><li>Define a Module with a name (不推荐,因为module name和目录相关)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">"my/cart"</span>, <span class="string">"my/inventory"</span>],</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">cart, inventory</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//return a function to define "foo/title".</span></span><br><span class="line">        <span class="comment">//It gets or sets the window title.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">title</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> title ? (<span class="built_in">window</span>.title = title) :</span><br><span class="line">                   inventory.storeName + <span class="string">' '</span> + cart.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>config一般和require一起用, config 定义好依赖之后, require可以直接使用它, require.js 会帮你加载你需要的依赖.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">requirejs.config(&#123;</span><br><span class="line">    <span class="comment">// 默认目录, require.js 会按相对目录去加载</span></span><br><span class="line">    baseUrl: <span class="string">'js/lib'</span>,</span><br><span class="line">    paths: &#123;</span><br><span class="line">        app: <span class="string">'../app'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the main app logic.</span></span><br><span class="line">requirejs([<span class="string">'jquery'</span>, <span class="string">'canvas'</span>, <span class="string">'app/sub'</span>],</span><br><span class="line"><span class="function"><span class="keyword">function</span>   (<span class="params">$,        canvas,   sub</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//jQuery, canvas and the app/sub module are all</span></span><br><span class="line">    <span class="comment">//loaded and can be used here now.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Require-JS-定义和发现机制&quot;&gt;&lt;a href=&quot;#Require-JS-定义和发现机制&quot; class=&quot;headerlink&quot; title=&quot;Require.JS 定义和发现机制&quot;&gt;&lt;/a&gt;Require.JS 定义和发现机制&lt;/h2&gt;&lt;p&gt;很多jque
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://mactive.github.io/tags/JavaScript/"/>
    
      <category term="DawnBlossom" scheme="http://mactive.github.io/tags/DawnBlossom/"/>
    
      <category term="Series" scheme="http://mactive.github.io/tags/Series/"/>
    
  </entry>
  
  <entry>
    <title>JS RegExp 正则表达式-简明使用指南</title>
    <link href="http://mactive.github.io/2016/12/27/js-regexp-sample-clear/"/>
    <id>http://mactive.github.io/2016/12/27/js-regexp-sample-clear/</id>
    <published>2016-12-27T07:23:00.000Z</published>
    <updated>2020-12-28T00:27:05.585Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript Regular Expressions </p><h3 id="正则学习的难点-违反直觉的地方"><a href="#正则学习的难点-违反直觉的地方" class="headerlink" title="正则学习的难点,违反直觉的地方"></a>正则学习的难点,违反直觉的地方</h3><ol><li>大量的缩写, 你可以写一堆,但也可以写一个  例如<code>\w</code>=<code>[a-zA-Z0-9_]</code></li><li>几个核心概念 anchors,meta,quantifiers,group</li><li>反义词不是 <code>!</code>开始 例如[\d]单字必须是数字 [^\d] 单子不是数字和 [\D]是一个功能</li><li>group的嵌套关系 \$0, \$1, \$2, \$n \$0是整体(如果命中的话), \$n 是你定义的第几个<code>()group</code></li><li>js 的 RegExp 支持的比较有限, 很多正则的高级用法并不支持</li></ol><a id="more"></a><h3 id="js中如何使用"><a href="#js中如何使用" class="headerlink" title="js中如何使用"></a>js中如何使用</h3><ul><li>regex.exec // 最强大功能最多</li><li>regex.test // 返回true/false注意他会改变 reg.lastIndex </li><li>string.match // 返回值是 group的数组, 利用regexp做字符提取</li><li>string.replace // 返回 string 利用regexp做字符替换</li></ul><p>VSCode, WebStorm 中都可以用正则来搜索事半功倍</p><h3 id="正则的几个核心概念"><a href="#正则的几个核心概念" class="headerlink" title="正则的几个核心概念"></a>正则的几个核心概念</h3><ul><li>anchors: 锚点</li><li>meta sequences: 匹配字符串</li><li>quantifiers: 度量  <code>?</code> <code>*</code> <code>+</code> <code>{n,m}</code></li><li>group: 组 (a|b) </li><li>flags/modifiers 扫面方式 /g 全局 /m 逐行</li></ul><h4 id="anchors"><a href="#anchors" class="headerlink" title="anchors"></a>anchors</h4><ul><li><code>^</code> 以什么字符开始</li><li><code>$</code> 以什么字符结束</li><li><code>\b</code> 单词边界 = <code>(^\w|\w$|\W\w|\w\W)</code> (^)表示不已xx开头<ul><li><code>/d\b/g</code> 找d而且d是单词的结尾,例如word, add中的最后一个d<a href="https://regex101.com/r/wVAFiN/7" target="_blank" rel="noopener">link</a></li></ul></li><li><code>\B</code> 不是单词的结尾<ul><li>可以是开头或者中间   </li></ul></li></ul><h4 id="meta-sequences"><a href="#meta-sequences" class="headerlink" title="meta sequences"></a>meta sequences</h4><ul><li><code>.</code> 任意单字符</li><li><code>\s</code> 任意空格,tab或者换行 \S 相反</li><li><code>\d</code> 任意数字 \D 相反</li><li><code>\w</code> 任意大小写字母和数字 \W 相反</li><li>还有一些hex和转义字符 例如 \/\/ 包含 ‘//‘ 双斜线</li></ul><h4 id="quantifiers"><a href="#quantifiers" class="headerlink" title="quantifiers"></a>quantifiers</h4><p>度量一定都跟在 meta 后面</p><ul><li><code>?</code> 0 - 1</li><li><code>*</code> 0 - non-limit </li><li><code>+</code> 1 - non-limit</li><li><code>{n}</code> n个 不能多也不能少</li><li><code>{n,m}</code> n - m 个, n必填,可以是0, m可以不写,默认 non-limit</li></ul><h4 id="group"><a href="#group" class="headerlink" title="group"></a>group</h4><p>你可以的定义很多组, 但是可以捕获的组最多9个 \$1 - \$9. \$0是个默认的全部字符变量的组</p><p><strong>string.match 例子</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'For more information, see Chapter 3.4.5.1'</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/see (chapter \d+(\.\d)*)/i</span>;</span><br><span class="line"><span class="keyword">var</span> found = str.match(re);</span><br><span class="line"><span class="comment">// found is a array [$0, $1, $2]</span></span><br></pre></td></tr></table></figure><p><strong>string.replace 例子</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">`800-456-7890</span></span><br><span class="line"><span class="string">555-456-7890</span></span><br><span class="line"><span class="string">4564567890`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;3&#125;)[\s-]?(\d&#123;3&#125;)[\s-]?(\d&#123;4&#125;)/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = str.replace(regex, <span class="string">"area code: $1"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure><h4 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h4><p>表达式最后 /g, /m, /gi, /gu 可以组合使用</p><ul><li><code>g</code> global,全局会搜索多行文本</li><li><code>m</code> multiline 每一行单独执行正则匹配</li><li><code>i</code> case insensitive 忽略大小写</li><li><code>y</code> sticky 用的不多</li><li><code>u</code> 支持unicode字符 例: <code>/𝌆/u</code></li></ul><h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p>这个<a href="https://regex101.com" target="_blank" rel="noopener">网站</a>有4种语言的正则写法, 有正则语法高亮显示, 有group的显示, 和一些常用用法还有library</p><p>一些练习示例<br><a href="https://regex101.com/r/wVAFiN/3" target="_blank" rel="noopener">https://regex101.com/r/wVAFiN/3</a><br><a href="https://regex101.com/r/wVAFiN/2" target="_blank" rel="noopener">https://regex101.com/r/wVAFiN/2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript Regular Expressions &lt;/p&gt;
&lt;h3 id=&quot;正则学习的难点-违反直觉的地方&quot;&gt;&lt;a href=&quot;#正则学习的难点-违反直觉的地方&quot; class=&quot;headerlink&quot; title=&quot;正则学习的难点,违反直觉的地方&quot;&gt;&lt;/a&gt;正则学习的难点,违反直觉的地方&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;大量的缩写, 你可以写一堆,但也可以写一个  例如&lt;code&gt;\w&lt;/code&gt;=&lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;几个核心概念 anchors,meta,quantifiers,group&lt;/li&gt;
&lt;li&gt;反义词不是 &lt;code&gt;!&lt;/code&gt;开始 例如[\d]单字必须是数字 [^\d] 单子不是数字和 [\D]是一个功能&lt;/li&gt;
&lt;li&gt;group的嵌套关系 \$0, \$1, \$2, \$n \$0是整体(如果命中的话), \$n 是你定义的第几个&lt;code&gt;()group&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;js 的 RegExp 支持的比较有限, 很多正则的高级用法并不支持&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="regexp" scheme="http://mactive.github.io/tags/regexp/"/>
    
      <category term="js" scheme="http://mactive.github.io/tags/js/"/>
    
      <category term="code" scheme="http://mactive.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>上海一周</title>
    <link href="http://mactive.github.io/2016/12/10/shanghai-one-week/"/>
    <id>http://mactive.github.io/2016/12/10/shanghai-one-week/</id>
    <published>2016-12-10T07:02:00.000Z</published>
    <updated>2020-12-28T00:27:05.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加班"><a href="#加班" class="headerlink" title="加班"></a>加班</h2><p>来MT第一次出差,然后连续加班6天.时间密度大概是平时的3倍.<br>大公司果然还是套路深, 如果想往上混除了必须拼或者表现的非常拼之外, 还需要经常搞校友资源和公司的资源, 然后技术的精进反而放到了一边. 大家都是想着怎么快速的把项目解决掉, 代码质量如何不怎么考虑. 非核心产品性能也不怎么考虑, 核心产品很多时候也是靠硬件堆出来的性能. </p><p>组织大了,项目如果初期搭的不好, 后期有没有拿出时间来重构的话, 会给后续维护的人带来很大的挫败感. 尤其很多的时候公司自己的轮子,或者和项目绑定的很紧的框架又会给大家带来很多困扰. 如何一边迭代一遍解耦是所有的前端工程师都面对的问题. 无论FE还是iOS</p><a id="more"></a><h2 id="饮食-交通"><a href="#饮食-交通" class="headerlink" title="饮食 交通"></a>饮食 交通</h2><p>上海日料好好吃啊, 又便宜. 而且这边日本的影响挺重的,吃的啊,用的啊, 大公司啊,生活方式 很多都像日本学习. 挺好的</p><h2 id="南方人-v-s-北方人"><a href="#南方人-v-s-北方人" class="headerlink" title="南方人 v.s. 北方人"></a>南方人 v.s. 北方人</h2><p>其实界限不是这么明显. 感觉只有小城市和大城市的区别, 小城的人更贴近自然,不是这么物化,大城市长大的孩子会对一些品牌或者物质会特别痴迷, 比如个别迷Nike,我在上海就碰到了周末的Nike店排长队等首发.或者特别精通日漫啦,星战了.对各种细节了如指掌,细想一下感觉也挺悲哀的. 人啦,还是要多出去走走,接触各种人和事情. 然后回到自己的小世界里继续升华迭代思路.</p><h2 id="博物馆里"><a href="#博物馆里" class="headerlink" title="博物馆里"></a>博物馆里</h2><p>古代皇帝就是最大的产品经理, 对各种瓷器有各种需求. 比如周世宗对柴窑有这种需求:雨过天晴云破处,这般颜色做将来.&lt;长物志&gt;中写柴窑: “柴窑最贵,世不一见…青如天,明如镜,薄如纸,声如磬”. 然后各代工匠做了各种demo也没有很多的成品问世. 工期来了估计也是各种加班. 其实各行各业的工匠从古代以来就积累很多和需求打交道的方法,比如做玉的,铸造钱币的,烧瓷器的, 跟软件工程的过程或者跟机械制造的的工程开发的过程也都是很像, 从需求理解,到选料(技术选型),到实际制作,然后再做模子,然后批量复制,量产,宣传上市.   </p><h2 id="文艺青年"><a href="#文艺青年" class="headerlink" title="文艺青年"></a>文艺青年</h2><p>武康路的大隐书店, 门口有只大猫咪🐈. 居然找到了很久之前就想看的<br>妹尾河童的窥探系列, 买了一本窥探工作间. 这本书简直是在家SOHO的人的最爱.<br>如何布置自己的工作间,如何规划工作动线. 各种不同职业的人如何工作的.</p><p>除了这些之外,这家书店有个挺大的和室,日式的喝茶的地方, 有榻榻米. 榻榻米下想必也是图书的收纳. 周五晚上去的时候还有人在那里录制视频, 类似罗辑思维的东西吧, 但是比老罗帅多了.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;加班&quot;&gt;&lt;a href=&quot;#加班&quot; class=&quot;headerlink&quot; title=&quot;加班&quot;&gt;&lt;/a&gt;加班&lt;/h2&gt;&lt;p&gt;来MT第一次出差,然后连续加班6天.时间密度大概是平时的3倍.&lt;br&gt;大公司果然还是套路深, 如果想往上混除了必须拼或者表现的非常拼之外, 还需要经常搞校友资源和公司的资源, 然后技术的精进反而放到了一边. 大家都是想着怎么快速的把项目解决掉, 代码质量如何不怎么考虑. 非核心产品性能也不怎么考虑, 核心产品很多时候也是靠硬件堆出来的性能. &lt;/p&gt;
&lt;p&gt;组织大了,项目如果初期搭的不好, 后期有没有拿出时间来重构的话, 会给后续维护的人带来很大的挫败感. 尤其很多的时候公司自己的轮子,或者和项目绑定的很紧的框架又会给大家带来很多困扰. 如何一边迭代一遍解耦是所有的前端工程师都面对的问题. 无论FE还是iOS&lt;/p&gt;
    
    </summary>
    
    
      <category term="life" scheme="http://mactive.github.io/tags/life/"/>
    
      <category term="code" scheme="http://mactive.github.io/tags/code/"/>
    
      <category term="travel" scheme="http://mactive.github.io/tags/travel/"/>
    
  </entry>
  
  <entry>
    <title>初冬杂感</title>
    <link href="http://mactive.github.io/2016/11/24/thinking_in_winter/"/>
    <id>http://mactive.github.io/2016/11/24/thinking_in_winter/</id>
    <published>2016-11-24T13:19:20.000Z</published>
    <updated>2020-12-28T00:27:05.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跑步"><a href="#跑步" class="headerlink" title="跑步"></a>跑步</h2><p>健身一直坚持, 一周3个5km. 周末如果陪孩子出去玩,我也换上运动装备全称跑步. 跑步让人高兴, 头脑清晰, 会容易冲动. 我跑步的时候会看一些国外越野跑比赛, 比如 <a href="https://www.youtube.com/watch?v=wUpRzyUrrlw&amp;t=122s" target="_blank" rel="noopener">UTMB - 环勃朗峰越野跑比赛</a>的视频, 很令人振奋,能多跑个50%左右</p><a id="more"></a><h2 id="大局观"><a href="#大局观" class="headerlink" title="大局观"></a>大局观</h2><p>一个人要读过些什么, 经历过什么, 见过那些人, 才能听到内心的声音. 才能不因为朋友圈的一篇文章而热血, 不因为道听途说的一个消息而悔恨.</p><p>其实什么都不需要, 只需要每天有一点安静的时间放空自己. 不用反思自己, 就是单纯的放空. 让大脑得到半个小时的休息, 跑步也是很好的. 可以不让你乱想. 就想中国画的留白, 不要让所有东西填满你. </p><p>有句名言说过: 中国的产品没有中国的营销做的好, 这些广告大师的包装手段, 公关技巧, 制造话题的能力. 早就对我们的人性挖掘的足够. 2000多年致力于忽悠人, 故意制造信息不对等的中华文化, 决定了当今中国在世界上的地位. 所以少看社交媒体, 基本上每一个都是软文. 都有背后的利益.</p><p>关掉朋友圈, 用省下时间进行严肃阅读, 哪怕听听各国音乐也好.</p><h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><p>随着北京越来越不欢迎你, 有钱的没钱人都在离开. 有人为了环境, 为了孩子有更好的教育, 说实话北京郊区的教育水平真的不比一些好的二线城市. 而且50%没有户口的儿童无法在北京上高中甚至初中, 因为买房也只能保证能接受义务教育.  我认识的一些朋友选择居家搬家去二线城市重新开始.</p><p>其实走与留区别都不大, 关键是你的人生追求是什么, 我们都太忙于赶路, 忘记了抬头看路. 每天多拿出一些时间来读书思考, 为自己的未来做做打算,到时候才不至于随大溜, 在一些关键的节点做出了鲁莽的决定.</p><p>end.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;跑步&quot;&gt;&lt;a href=&quot;#跑步&quot; class=&quot;headerlink&quot; title=&quot;跑步&quot;&gt;&lt;/a&gt;跑步&lt;/h2&gt;&lt;p&gt;健身一直坚持, 一周3个5km. 周末如果陪孩子出去玩,我也换上运动装备全称跑步. 跑步让人高兴, 头脑清晰, 会容易冲动. 我跑步的时候会看一些国外越野跑比赛, 比如 &lt;a href=&quot;https://www.youtube.com/watch?v=wUpRzyUrrlw&amp;amp;t=122s&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;UTMB - 环勃朗峰越野跑比赛&lt;/a&gt;的视频, 很令人振奋,能多跑个50%左右&lt;/p&gt;
    
    </summary>
    
    
      <category term="life" scheme="http://mactive.github.io/tags/life/"/>
    
      <category term="thinking" scheme="http://mactive.github.io/tags/thinking/"/>
    
  </entry>
  
  <entry>
    <title>近期学习和工作计划</title>
    <link href="http://mactive.github.io/2016/11/07/Learn-And-Study-2016-11-07/"/>
    <id>http://mactive.github.io/2016/11/07/Learn-And-Study-2016-11-07/</id>
    <published>2016-11-07T11:30:20.000Z</published>
    <updated>2020-12-28T00:27:05.583Z</updated>
    
    <content type="html"><![CDATA[<p>最近荒废了总结, 学习也没有很明确的方向, 参加了一次线下<a href="http://www.bagevent.com/event/207773?bag_track=devlink" target="_blank" rel="noopener">iOS峰会</a>之后.才感觉找回来点状态, 还来鸡血还要不断的打才行. :P</p><p>读了一本书,精进-如何成为一个很厉害的人. 感觉还不错,之后做点摘抄放在这里.推荐给了老婆读一读</p><h2 id="Learn-And-Study-学习和开发计划"><a href="#Learn-And-Study-学习和开发计划" class="headerlink" title="Learn And Study 学习和开发计划"></a>Learn And Study 学习和开发计划</h2><ul><li>RACBabyDoodle<ul><li>iOS Animation 应用</li><li>BabyDoodleAdm 后台项目 leancloud</li></ul></li><li>typescript 项目实战<ul><li>webpack &amp; babel &amp; 前端 工具链 的一些配置</li><li>typescript 高阶用法 以及实战</li></ul></li><li>Vue h5组件 <ul><li>Vue 如何用一个组件 </li><li>Vue 如何写一个组件</li><li>Angular 实战学习 图书阅读, 思考和Vue的不同</li></ul></li><li>前段学习<ul><li>typescript</li><li>Angular2 </li><li>FrontMaster JS 基础学习,总结blog 等等</li></ul></li><li>Lego 翻译和报道<ul><li>公众号文章</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近荒废了总结, 学习也没有很明确的方向, 参加了一次线下&lt;a href=&quot;http://www.bagevent.com/event/207773?bag_track=devlink&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS峰会&lt;/a&gt;之后.
      
    
    </summary>
    
    
      <category term="life" scheme="http://mactive.github.io/tags/life/"/>
    
      <category term="learn" scheme="http://mactive.github.io/tags/learn/"/>
    
      <category term="thinking" scheme="http://mactive.github.io/tags/thinking/"/>
    
  </entry>
  
  <entry>
    <title>iOS 朝花夕拾 -- 1 - Protocol</title>
    <link href="http://mactive.github.io/2016/09/21/iOS-dawn-blossom-1/"/>
    <id>http://mactive.github.io/2016/09/21/iOS-dawn-blossom-1/</id>
    <published>2016-09-20T23:43:20.000Z</published>
    <updated>2020-12-28T00:27:05.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><blockquote><p>断断续续做iOS开发也有5年时间了,中间不务正业的搞了2年JS.回过头来在看iOS的变化非常的快.虽然swift也在学习,面向protocol和struct编程嘛.但感觉Objective-C的很多知识点的深层次原理没有彻底搞懂. 收到业界一些大牛的启发和指导, 有人持续写刨根问底系列, 有人做架构对比分析, 微观的也好,宏观的也好. 本系列文章也想从自己的角度尝试理解一些问题, 将一些之前忽视的花朵重新拾起来品玩, 说不定有新的发现. 捎带写一些自己的感受, 希望让自己活得明白一些.</p></blockquote><a id="more"></a><h2 id="发明Protocol的原因"><a href="#发明Protocol的原因" class="headerlink" title="发明Protocol的原因"></a>发明Protocol的原因</h2><p>从 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithProtocols/WorkingwithProtocols.html" target="_blank" rel="noopener">Apple官方文档</a>,<a href="http://wiki.jikexueyuan.com/project/programming-with-objective-c/working-with-protocols.html" target="_blank" rel="noopener">中文</a>可以得到的知识点.</p><h3 id="Protocol-本身是可以多重继承的"><a href="#Protocol-本身是可以多重继承的" class="headerlink" title="Protocol 本身是可以多重继承的"></a>Protocol 本身是可以多重继承的</h3><p>下面代码的含义是, 叫Mark的这个Protocol, 同时具备了 NSObject, NSCopying, NSCoding协议的内容. 因为,</p><ol><li><code>NSCopying</code> 协议有 <code>- copyWithZone:</code>方法,而且是@Required 的</li><li><code>NSCoding</code> 协议有 <code>- initWithCoder:</code>和<code>- encodeWithCoder:</code>方法,也是@Required 的</li><li><code>NSObject</code> 是类也是协议, 比较特殊. 而且没有必须要实现的协议方法.<br>所以, 所有实现MyProtocol协议的类,必须实现 上面这三个方法.</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@protocol</span> MyProtocol &lt;NSObject, NSCopying, NSCoding&gt;</span><br><span class="line">...</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><h3 id="符合协议的实现的继承"><a href="#符合协议的实现的继承" class="headerlink" title="符合协议的实现的继承"></a>符合协议的实现的继承</h3><ul><li>OC不像C++可以有多重继承,Objective-C是单一继承的, 如果想要做到一个类同时具有多种类的能力(属性和方法), 可以通过Protocol实现,弥补了OC语言在OOP上的缺陷</li></ul><p>MyClass 需要实现 MyProtocol， AnotherProtocol， YetAnotherProtocol 这三个协议中标注必须要实现的方法. 但同时也享有了这三个协议中定义的 @porperty<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">MyClass </span>: NSObject &lt;MyProtocol， AnotherProtocol， YetAnotherProtocol&gt;</span><br><span class="line">...</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p><h3 id="OC-Protocol-和-Java-Interface-可以简单类比"><a href="#OC-Protocol-和-Java-Interface-可以简单类比" class="headerlink" title="OC Protocol 和 Java Interface 可以简单类比"></a>OC Protocol 和 Java Interface 可以简单类比</h3><ul><li>OC -&gt; @interface = Java -&gt; Class</li><li>OC -&gt; @protocol = Java -&gt; interface</li></ul><h2 id="Protocol-的特性"><a href="#Protocol-的特性" class="headerlink" title="Protocol 的特性"></a>Protocol 的特性</h2><ul><li>@required 所有实现这个协议的类,必须实现的方法</li><li>@optional 可选实现</li></ul><blockquote><p>在Objective-C 2.0之後加了@required跟@optional的語法,有些OC1.0时代的代码没有这两个关键字,那么都是<strong>必须要实现的</strong></p></blockquote><p>举例,最常用的 <code>UITableViewDataSource</code>, rows必须要实现,但sections可以不用实现.</p><p>从 iOS 10.0/Frameworks/UIKit/UITableView.h  Line 297 节选<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@protocol</span> UITableViewDataSource&lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须实现的</span></span><br><span class="line"><span class="variable">@required</span></span><br><span class="line"></span><br><span class="line">- (NSInteger)<span class="attribute">tableView</span>:(UITableView *)tableView <span class="attribute">numberOfRowsInSection</span>:(NSInteger)section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选实现的</span></span><br><span class="line"><span class="variable">@optional</span></span><br><span class="line"></span><br><span class="line">- (NSInteger)<span class="attribute">numberOfSectionsInTableView</span>:(UITableView *)tableView;              <span class="comment">// Default is 1 if not implemented</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p><h2 id="Protocol-的使用"><a href="#Protocol-的使用" class="headerlink" title="Protocol 的使用"></a>Protocol 的使用</h2><p><img src="/images/protocol_1.png" alt></p><ul><li>A.methodA 和 B.methodB 都是必须要实现的,因为他们有@required</li><li><ul><li>所以这个MyClass的类需要实现这些方法,</li></ul></li><li><ul><li>他同时也获得了.name 属性,因为是readonly的, 所以需要自己实现get方法</li></ul></li><li>这个delegate属性很有意思, 他是用Protocol B来定义的, 所以他具有了delgate的所有属性和方法.将delegate指向谁,谁就需要负责实现 @required 的方法, 具体实现也会打到哪里去.</li></ul><blockquote><p>使用Protocol相当于 把你在 <code>.h</code> 文件中 @interface 和 @end 之间的内容, 按照OOP的方式拆分到各处去.方便复用和继承, 都是是属性定义和方法定义<br>使用Category, 相当于 <code>.m</code>文件中的  @implementation 和 @end 之前的内容. 还可以获得方法的定义和实现.</p></blockquote><p>PS: 但是Category不允许为已有的类添加新的属性或者成员变量。但是可以通过runtime.h中objc_getAssociatedObject / objc_setAssociatedObject <a href="http://www.cnblogs.com/wupher/archive/2013/01/05/2845338.html" target="_blank" rel="noopener">黑魔法实现</a></p><h3 id="Gist完整例子代码"><a href="#Gist完整例子代码" class="headerlink" title="Gist完整例子代码"></a>Gist完整例子代码</h3><script src="//gist.github.com/0ddba230d8a79d470303111027628b1a.js?file=MyClass.h"></script><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>Protocol 只有一个文件 MyProtocol.h,他本身没有实现文件</li><li>Protocol 对现实他的类有约束作用,必须实现,可选实现. 约束作用会通过继承<strong>穿透</strong>.</li><li>Protocol 既可以约束类, 也可以作为属性定义变量</li><li>Protocol 和 Category 是 Objective-C OOP的两大杀器</li></ul><p>2011年出版的 <a href="https://www.amazon.com/Pro-Objective-C-Design-Patterns-iOS/dp/1430233303" target="_blank" rel="noopener">Pro Objective-C Design Patterns for iOS</a> 从未再版,但依然还很有深度, 本文也是对其中一个知识点的扩展. 作者在Apple工作多年, 至今还奋斗在Cocoa的前线. </p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>不知道最近Swift提到的 POP - 面向协议和结构体编程, 是不是跟这个Protocol有些关系, 但Swift应该有完整的OO的概念和FP的概念.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="http://kaochenlong.com/2010/12/11/protocol-in-objective-c/" target="_blank" rel="noopener">Protocol in Objective-C</a></p></li><li><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithProtocols/WorkingwithProtocols.html" target="_blank" rel="noopener">Apple官方文档</a></p></li><li><p><a href="http://www.cnblogs.com/chijianqiang/archive/2012/06/22/objc-category-protocol.html" target="_blank" rel="noopener">Objective-C——消息、Category和Protocol</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;断断续续做iOS开发也有5年时间了,中间不务正业的搞了2年JS.回过头来在看iOS的变化非常的快.虽然swift也在学习,面向protocol和struct编程嘛.但感觉Objective-C的很多知识点的深层次原理没有彻底搞懂. 收到业界一些大牛的启发和指导, 有人持续写刨根问底系列, 有人做架构对比分析, 微观的也好,宏观的也好. 本系列文章也想从自己的角度尝试理解一些问题, 将一些之前忽视的花朵重新拾起来品玩, 说不定有新的发现. 捎带写一些自己的感受, 希望让自己活得明白一些.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="DawnBlossom" scheme="http://mactive.github.io/tags/DawnBlossom/"/>
    
      <category term="Series" scheme="http://mactive.github.io/tags/Series/"/>
    
      <category term="iOS" scheme="http://mactive.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 朝花夕拾 -- 1</title>
    <link href="http://mactive.github.io/2016/08/08/JavaScript-dawn-blossom-1/"/>
    <id>http://mactive.github.io/2016/08/08/JavaScript-dawn-blossom-1/</id>
    <published>2016-08-08T04:40:35.000Z</published>
    <updated>2020-12-28T00:27:05.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Apply-amp-Call-Argument"><a href="#Apply-amp-Call-Argument" class="headerlink" title="Apply &amp; Call Argument"></a>Apply &amp; Call Argument</h2><p>call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。因为 JavaScript 的函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。</p><p>二者的作用完全一样，只是接受参数的方式不太一样。例如，有一个函数 func1 定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>就可以通过 func1.call(this, arg1, arg2); 或者 func1.apply(this, [arg1, arg2]); 来调用。其中 this 是你想指定的上下文，他可以任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。</p><p>JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时，用 call，而不确定的时候，用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来便利所有的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">splat</span>(<span class="params">fun</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> fun.apply(<span class="literal">null</span>,array); <span class="comment">// null 没有上下文,等待参数传入</span></span><br><span class="line"><span class="comment">// apply 只能接收数组类型的参数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addArrayElements = splat(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123; <span class="keyword">return</span> x + y&#125;);</span><br><span class="line">addArrayElements([<span class="number">1</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="bind-Function-prototype-bind"><a href="#bind-Function-prototype-bind" class="headerlink" title="bind - Function.prototype.bind()"></a>bind - Function.prototype.bind()</h2><p>bind() 方法与 apply 和 call 很相似 是可以改变函数体内 this 的指向。<br>react es6 撰写方式的代码经常需要 <code>.bind(this)</code>, 绑定作用域</p><p>MDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bar(); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> func = bar.bind(foo);</span><br><span class="line">func(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这里我们创建了一个新的函数func, 当使用bind绑定一个作用域之后.当func被执行的时候实际上是bar被执行.<br>然后bar中的this 指向的是foo. </p><p>如果你不想新建func也行,写作 bar.bind(foo)(). 因为bind是function原型中的方法.所以必须是一个<br>function类型的对象.bind(xx).当然他也返回一个function类型的对象</p><h2 id="Exception-throw-try-catch"><a href="#Exception-throw-try-catch" class="headerlink" title="Exception throw try catch"></a>Exception throw try catch</h2><h3 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h3><ol><li>所有try中的执行代码,包括func中的,只要有抛出 Error,就会被catch住,一旦有throw,throw之后的代码就不会执行</li><li>如果try catch 有嵌套关系,那么只有同级的catch会处理try中throw出来的异常,如果想向上传递需要在catch中 继续throw,确保他的外侧能接受到</li><li>try catch 经常和 finally<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch" target="_blank" rel="noopener">一起使用</a> </li><li>系统内置了一写 Error,例如TypeError,ReferenceError,EvalError,SyntaxError</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSome = <span class="function"><span class="keyword">function</span>(<span class="params">thing</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"UserException: "</span>+thing);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'here i try'</span>);</span><br><span class="line">  doSome(<span class="string">"eat"</span>); <span class="comment">// 执行到这个throw的时候会停止执行</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"this is a TypeError"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(e)&#123;</span><br><span class="line">  <span class="keyword">if</span>(e <span class="keyword">instanceof</span> <span class="built_in">TypeError</span>)&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(e.message,e.name);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(e.message,e.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Apply-amp-Call-Argument&quot;&gt;&lt;a href=&quot;#Apply-amp-Call-Argument&quot; class=&quot;headerlink&quot; title=&quot;Apply &amp;amp; Call Argument&quot;&gt;&lt;/a&gt;Apply &amp;amp; Call Argument&lt;/h2&gt;&lt;p&gt;call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。因为 JavaScript 的函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。&lt;/p&gt;
&lt;p&gt;二者的作用完全一样，只是接受参数的方式不太一样。例如，有一个函数 func1 定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; func1 = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;arg1, arg2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就可以通过 func1.call(this, arg1, arg2); 或者 func1.apply(this, [arg1, arg2]); 来调用。其中 this 是你想指定的上下文，他可以任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。&lt;/p&gt;
&lt;p&gt;JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时，用 call，而不确定的时候，用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来便利所有的参数。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;splat&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;fun&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;array&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; fun.apply(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;,array); &lt;span class=&quot;comment&quot;&gt;// null 没有上下文,等待参数传入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// apply 只能接收数组类型的参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; addArrayElements = splat(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y&lt;/span&gt;)&lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x + y&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;addArrayElements([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://mactive.github.io/tags/JavaScript/"/>
    
      <category term="DawnBlossom" scheme="http://mactive.github.io/tags/DawnBlossom/"/>
    
      <category term="Series" scheme="http://mactive.github.io/tags/Series/"/>
    
  </entry>
  
</feed>
